{"/":{"title":"ü™¥ Sistemas Distribuidos","content":"\nResumen de la materia **Sistemas Distribuidos**\n\n## √çndice\n- [Distribuciones Linux](Examen1/DistribucionesLinux.md)\n- [Que es](Examen1/Quees.md)\n- [Modelos Fundamentales](Examen1/ModelosFundamentales.md)\n- [TCP-UDP](Examen1/TCP-UDP.md)\n- [Raids](Examen1/Raids.md)\n- [Arquitecturas](Examen1/Aruitecturas.md)\n\n- [Seguridad](Examen2/Seguridad.md)\n- [Teorema CAP](Examen2/CAP.md)\n- [VPN IPsec](Examen2/VPNIPsec.md)\n- [DNS](Examen2/DNS.md)\n- [Exclusion](Examen2/Exclusion.md)\n- [Hipervisores](Examen2/Hipervisores.md)\n- [LVM](Examen2/LVM.md)\n- [Transacciones](Examen2/Tansacciones.md)\n- [Relojes](Examen2/Relojes.md)\n","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/Examen1/Aruitecturas":{"title":"","content":"# Arquitecturas\n## Modelos Arquitect√≥nicos En Sistemas Distribuidos \nUn modelo arquitect√≥nico puede ser definido como un prototipo o representaci√≥n de la estructura de un sistema, construido con el fin de estudiar distintos aspectos en torno al mismo, como pueden ser el dise√±o o la eficiencia. \n\nLos tipos de modelos arquitect√≥nicos se diferencian en \n- El reparto de responsabilidades entre componentes del sistema\n- La ubicaci√≥n de los componentes del sistema \nTipos de modelos \n- Cliente-servidor \n- Servicios proporcionados por m√∫ltiples servidores \n- Servidores proxy y cach√©s\n- Otros derivados\n- Sistemas de igual a igual (peer to peer)\n\n## Arquitectura De Software \nEl t√©rmino arquitectura de software puede ser definido como aquella organizaci√≥n l√≥gica que se enfoca en los componentes de software y como estos interact√∫an con otras estructuras.\n\n### Clasificaci√≥n \nUna vez entendiendo dicho t√©rmino es que se puede hablar de los siguientes modelos: \n#### Modelo Arquitect√≥nico En Capas\nComo su nombre indica, este modelo proporciona un enfoque modular al software, es decir, separa cada componente con el fin de ser m√°s eficiente; de esta manera, se crea un orden en la secuencia de pasos y cuando se realiza una modificaci√≥n a una capa de manera independiente no se afecta al resto del sistema.\n\nPara dejar la idea un poco m√°s clara, un ejemplo que se puede dar de este tipo de arquitectura es el modelo OSI (modelo de interconexi√≥n de sistemas abiertos) el cual utiliza este modelo para obtener mejores resultados. \n\n#### Modelo Arquitect√≥nico Basado En Objetos\nEl modelo basado en objetos se basa en la idea de tener una cierta disposici√≥n de objetos que se encuentran d√©bilmente acoplados y sin una arquitectura fija. A diferencia del anterior modelo no existe una secuencia de pasos a seguir, en cambio, la interacci√≥n est√° dada a trav√©s de un conector o interfaz donde cada objeto puede interactuar con otro a trav√©s de la llamada de uno o varios m√©todos.\n\nEjemplo de este tipo de modelo arquitect√≥nico son los sistemas de navegaci√≥n y ayuda a la gesti√≥n de transportes, donde distintos componentes (objetos) interact√∫an entre s√≠.\n\n#### Modelo Arquitect√≥nico Centrado En Datos\nEste modelo de arquitectura funciona en base a un repositorio de datos central, tal y como indica su nombre, desde el cual se pueden ingresar y solicitar datos. \n\nUn ejemplo simple de este tipo de modelo es el de un almac√©n de productos el cual ‚Äúingresa y actualiza‚Äù datos cuando recibe nuevos productos los cuales pueden ser a su vez solicitados por sus clientes.\n\n#### Modelo Arquitect√≥nico Basado En Eventos\nAl igual que en los casos anteriores el nombre de esta arquitectura resume de buena manera su funcionamiento, el cual est√° dado a trav√©s de eventos; es decir, cuando ocurre un evento el sistema suscrito recibe una notificaci√≥n y act√∫a en consecuencia a la misma. \n\nUna de las ventajas y principales diferencias con los anteriores modelos explicados es que los componentes de este modelo est√°n acoplados de manera flexible, lo que facilita el modificarlos, agregarlos o eliminarlos. Ejemplo de este modelo es Facebook, debido a las caracter√≠sticas antes mencionadas.\n## Arquitetura del sistema\nEste concepto puede ser definido como aquella arquitectura que se basa en el sistema en si y en la ubicaci√≥n de todos los componentes del mismo. Teniendo como punto el de un sistema distribuido, se puede decir que los modelos arquitect√≥nicos que m√°s relevancia tienen en este √°mbito son dos.\n\n### Modelo Arquitect√≥nico Cliente-Servidor (Centralizadas)\nEste modelo, como su nombre indica consta de un cliente y un servidor. El servidor es donde se encuentran todos los procesos y el cliente es donde el usuario interact√∫a con dicho servidor; en ese sentido si el cliente solicita algo al servidor, este le responder√°. Este es un modelo que es m√°s estable y seguro que el modelo punto a punto, pero es m√°s lento que el mismo. El ejemplo m√°s grande que se puede dar de un sistema de este tipo es de la World Wide Web, donde se utiliza un programa (navegador) como cliente\n\n### Modelo Arquitect√≥nico Punto A Punto (Descentralizadas)\nTambi√©n llamado peer-to-peer o P2P, este modelo funciona teniendo como base la falta de un control central en un sistema distribuido; es decir, un nodo puede actuar como cliente o como servidor en cualquier momento; si el nodo hace una solicitud es tratado como un cliente y si por el contrario proporciona algo en respuesta a una solicitud se lo trata como el servidor. Existen tres tipos de Modelos P2P, el modelo estructurado, el no estructurado y el h√≠brido. Ejemplo de esto son los servicios de telefon√≠a por Internet.\n\n### Hibiridas\nMezcla de las 2\n","lastmodified":"2022-06-29T06:05:34.847071901Z","tags":null},"/Examen1/DistribucionesLinux":{"title":"üíª Distribucion de Linux","content":"\nUna distribuci√≥n es un conjunto de programas GNU / Linux debidamente precompilados y configurados para funcionar juntos. Adicionalmente, la mayor√≠a de distribuciones incluyen otros componentes que aportan valor al conjunto. Una distribuci√≥n es una de las formas en que las empresas pueden ganar dinero con software libre. \n\nExisten organizaciones comerciales que se dedican a empaquetar juntos los programas, incluirlos en alg√∫n medio, a√±adir un manual de instrucciones y proporcionar soporte t√©cnico. La mayor√≠a de fabricantes de distribuciones reinvierten una parte de sus beneficios en iniciativas que ayuden a la comunidad de software libre. Tambi√©n existen distribuciones realizadas por voluntarios y que no tienen √°nimo de lucro.\n\n## Caracteristicas\nEntre las cosas que se pueden esperar de una distribuci√≥n moderna se cuentan: \n\t‚Ä¢ Un programa de instalaci√≥n que gu√≠e al usuario desde el principio e instale los paquetes b√°sicos. \n\t‚Ä¢ Un gestor de paquetes que se encargue de proporcionar el interfaz necesario para que el administrador pueda instalar y desinstalar programas de una manera f√°cil. \n\t‚Ä¢ Un entorno gr√°fico (normalmente KDE o GNOME), con el que se integren el resto de los programas. \n\t‚Ä¢ Manuales de instalaci√≥n y uso y documentaci√≥n adicional sobre los programas. \n\t‚Ä¢ Un sistema de seguimiento de errores (bugs) y fallos de seguridad que proporcione al usuario versiones corregidas de los programas lo m√°s r√°pido posible cuando se detecte un fallo.\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/distlinuxcarac.png)\n\n## Ramas diferentes\n- Basadas en Redhat: Sistema rpm (RedHat, Madrake, SuSE) \n- Basadas en Debian: Sistema de (Debian)\n\n### Redhat\nEs la distribuci√≥n m√°s usada en el mundo; es f√°cil de instalar y de usar. Su gestor de paquetes RPM se ha convertido en un est√°ndar en el mundo GNU/Linux. Incluye multitud de herramientas gr√°ficas.\n\n### Debian\nEs la que mayor cantidad de software contiene. Realizada enteramente por voluntarios y basada exclusivamente en software libre. Su sistema de paquetes dispone de caracter√≠sticas realmente potentes, lo que hace del uno de sus puntos fuertes.\n\n### Distribuiciones\n- stable (Woody): Distribuci√≥n oficial m√°s reciente. Versi√≥n de producci√≥n. Soporte de seguridad. \n- testing (Sarge): Distribuci√≥n de ‚Äúpruebas‚Äù. Versiones de paquetes m√°s recientes a√∫n no aceptadas en la rama estable. \n- unstable (Sid): Distribuci√≥n de desarrollo de Debian.\n\n## Por que Debian\n### M√∫ltiples arquitecturas y kernels \nActualmente Debian soporta un impresionante n√∫mero de arquitecturas CPU: alpha, amd64, armel, hppa, i386, ia64, mips, mipsel, powerpc, s390, y sparc. Tambi√©n corre con los kernels GNU Hurd y FreeBSD adem√°s de Linux, y con la utilidad debootstrap es dif√≠cil que encuentre un dispositivo que no pueda correr Debian.\n\n### Software de seguridad \nMuchos desconocen que cualquier cosa enviada por la red puede ser le√≠da por cualquier m√°quina entre usted y el receptor. Debian tiene paquetes del famoso software GPG (y PGP) que permite enviar correo entre usuarios preservando su privacidad. Adem√°s, ssh permite crear conexiones seguras a otras m√°quinas que tengan ssh instalado.\n\n### Distribuciones mas usadas\nUna distribuci√≥n derivada de Debian es una distribuci√≥n que est√° basada en el trabajo hecho en Debian pero que tiene sus propias metas, identidad y audiencia, y que ha sido creada por una entidad independiente de Debian. Las distribuciones derivadas modifican Debian para alcanzar sus propias metas. \n\nDebian da la bienvenida y anima a las organizaciones que quieran desarrollar nuevas distribuciones basadas en Debian. Conforme al esp√≠ritu del contrato social de Debian, esperamos que las distribuciones derivadas aporten su trabajo a Debian y a los proyectos originales (¬´upstream¬ª), de forma que todo el mundo se pueda beneficiar de las mejoras que introduzcan.\n\n### Distribuciones destacadas\n‚Ä¢ Grml: sistema ¬´en vivo¬ª (¬´live system¬ª) para administradores del sistema. \n‚Ä¢ Kali Linux: auditor√≠as de seguridad y pruebas de penetraci√≥n. \n‚Ä¢ Purism PureOS: publicaci√≥n contin√∫a enfocada hacia la privacidad, seguridad y comodidad, respaldada por la FSF. \n‚Ä¢ Tails: protecci√≥n de la privacidad y anonimato. \n‚Ä¢ Ubuntu: popularizar Linux en todo el mundo","lastmodified":"2022-06-29T06:05:34.847071901Z","tags":null},"/Examen1/Modelos-de-interaccion/ModeloFallos":{"title":"","content":"# Modelo de Fallos\n## Tipos de fallo seg√∫n entidad\n- Fallos de proceso\n- Fallos de comunicaci√≥n\n## Tipo de fallo seg√∫n el problema\n- Fallos por omisi√≥n **Afecta al canal**\n\t-  No se consigue realizar una acci√≥n que se deber√≠a poder hacer\n\t-  Un mensaje insertado en un b√∫fer de mensajes salientes nunca llega al b√∫fer de mensajes entrantes del destino\n\n- Fallos arbitrarios (bizantinos)¬† **Afecta al proceso o canal**\n\t- Errores de cualquier tipo, fuera del esquema de mensajes\n\t- El proceso/Canal presenta un comportamiento arbitrario: omisiones, paradas, env√≠os o pasos incorrectos sin patr√≥n claro\n\n- Fallos de temporizaci√≥n\n\t- Superaci√≥n de tiempos l√≠mite en un sistema s√≠ncrono\n\n- Fallo del procesamiento (crash)¬† **Afecta al proceso**\n\t- Un mensaje insertado en un b√∫fer de mensajes saliente, otros procesos no pueden detectar la parada\n\n- Fallo parada (fail-stop)¬† **Afecta al proceso**\n\t- Fallo de procesamiento que puede ser detectado con certeza por el resto de los procesos\n\t- El proceso para y permanece parado, otros procesos pueden detectar la parada\n\n- Detecci√≥n del fallo por timeouts (s√≠ncrono)\n\t- Si el proceso no responde consideramos que ha habido un fallo\n\t- En sistemas as√≠ncronos, nunca podemos estar seguros\n\n- Fallo por omisi√≥n en comunicaciones\n\t-  Fallo por omisi√≥n de env√≠o¬† **Afecta al proceso**\n\t\t-  Un proceso completa el envio pero no se coloca el mensaje en el b√∫fer de mensajes salientes\n\t- Fallo por omisi√≥n de comunicaci√≥n¬†**Afecta al canal**\n\t- Fallo por omisi√≥n de recepci√≥n¬† **Afecta al proceso**\n\t\t- El mensaje se coloca en el buffer de recepci√≥n pero el proceso no lo recibe\n\n## Fallos de temporizaci√≥n\n- Sistemas s√≠ncronos\n\t- Reloj Afecta al proceso\n\t\t- El reloj local del proceso excede el l√≠mite de su tasa de deriva respecto al tiempo de referencia\n\t- Prestaciones Afecta el proceso\n\t\t- El proceso excede el l√≠mite sobre el intervalo\n\t- Prestaciones Afecta el canal\n\t\t- La transmisi√≥n de un mensaje toma m√°s tiempo que el tiempo permitido\n- Sistemas As√≠ncronos\n\t- No hay fallos de temporizaci√≥n\n## Comunicaci√≥n fiable entre procesos\nSe debe cumplir la:\n- Validez\n\t- Cualquier mensaje en el b√∫fer de mensajes salientes llegar√° eventualmente al b√∫fer de mensajes entrantes\n\t- Es decir, no hay fallos por omisi√≥n en el canal\n- Integridad\n\t- El mensaje recibido es id√©ntica al enviado y no se repiten mensajes\n\t\t- Protocolo que adjunta n√∫meros de secuencia a los mensajes\n\t\t- Canales de comunicacion seguros\n\t- No hay fallos bizantino","lastmodified":"2022-06-29T06:05:34.847071901Z","tags":null},"/Examen1/Modelos-de-interaccion/ModelosInteraccion":{"title":"","content":"# Modelos de interaccion\nRespecto a la interacci√≥n, los sistemas distribuidos deben tener en cuenta que\n- Hay limitaciones debidas a la comunicaci√≥n\n- Es imposible predecir el retraso con el que llega un mensaje\n- Es imposible tener una noci√≥n global de tiempo\n\t- La ejecuci√≥n es no determinista y dif√≠cil de depurar\n\n## Algoritmo distribuido\nDefinici√≥n de los pasos que hay que llevar a cabo por cada uno de los procesos del sistema, incluyendo los mensajes de transmisi√≥n entre ellos.\n\n## Prestaciones del canal de comunicaci√≥n\n### Latencia\n- Retardo entre el env√≠o de un mensaje y su recepci√≥n\n- Ancho de banda\n- Informaci√≥n que puede transmitirse en un intervalo de tiempo: Fluctuaci√≥n (jitter)\n- Variaci√≥n del tiempo invertido en repartir una serie de mensajes\n\n## Protocolos de Enrutamiento\n- RIP: Es un protocolo de enrutamiento que se basa en el n√∫mero de saltos para decidir cu√°l es la mejor ruta hacia una red de destino.\n- OSPF: Es un protocolo de enrutamiento cuya m√©trica es el costo. Aquella ruta que posea el menor costo ser√° la ideal y la que ser√° seleccionada como mejor camino hacia una red de destino.\n- BGP: BGP significa Border Gateway Protocol y se utiliza para permitir la comunicaci√≥n entre los routers de borde pertenecientes a sistemas aut√≥nomos diferentes. BGP es un protocolo de gran importancia para las empresas Telco y para los ISPs.\n- EIGRP: Fue desarrollado por la empresa Cisco Systems y utiliza una m√©trica compuesta para decidir la mejor ruta hacia una red de destino. Puedes obtener m√°s detalles de su configuraci√≥n y funcionamiento en nuestro Curso gratuito de Fundamentos de EIGRP que encontrar√°s en nuestra plataforma de Telecapp Academy.\n\n## Relojes y eventos de tiempo\nCada computador tiene su propio reloj interno (reloj local)\n- Puede usarse en procesos locales para marcas de tiempo \n### Tasa de deriva de reloj (clock drift rate)\n- Evoluci√≥n de la diferencia entre un reloj local y un reloj de referencia ‚Äúperfecto‚Äù\n- Receptores GPS\n- Network Time Protocol (NTP)\n- Mecanismos de ordenaci√≥n de eventos\n\n### Dos tipos de modelo de interacci√≥n\n- Sincrono\n- Asincrono\n\nEn la comunicaci√≥n sincr√≥nica, los datos se transfieren en forma de tramas, mientras que, en la asincr√≥nica, los datos se env√≠an de un byte en un byte. La transmisi√≥n sincr√≥nica necesita una se√±al de reloj entre el emisor y el receptor para informar al segundo sobre la llegada del nuevo byte o mensaje.\n\n#### Modelos Sincr√≥nicos\nConocimiento de caracter√≠sticas temporales:\n- El tiempo de ejecuci√≥n de cada etapa de un proceso tiene ciertos l√≠mites inferior y superior conocidos \n- Cada mensaje transmitido sobre un canal se recibe en un tiempo l√≠mite conocido\n\t- Cada proceso tiene un reloj local cuya tasa de deriva sobre el tiempo de referencia tiene un l√≠mite conocido\n- A nivel te√≥rico, podemos establecer unos l√≠mites para tener una idea aproximada de c√≥mo se comportar√° el sistema \n- A nivel pr√°ctico, es imposible garantizar esos l√≠mites siempre \n- Aunque a veces se pueden utilizar, por ejemplo, como tineos\n\n#### Modelos Asincr√≥nicos\nNo hay limitaciones en cuanto a:\n- Velocidad de procesamiento.\n- Retardos en la transmisi√≥n de mensajes.\n- Tasas de deriva de los relojes.\n- Los sistemas distribuidos reales suelen ser as√≠ncronos. \n\tPor ejemplo, Internet.\n- Una soluci√≥n v√°lida para un sistema as√≠ncrono lo es tambi√©n para uno s√≠ncrono.","lastmodified":"2022-06-29T06:05:34.847071901Z","tags":null},"/Examen1/Modelos-de-interaccion/ModelosSeguridad":{"title":"","content":"# Modelos de Seguridad\nLa seguridad en un sistema distribuido se basa en la seguridad de los procesos y canales utilizados\n- Entendida como seguridad de objetos\n- Almacenados e invocados por los procesos\n- Transmitidos a trav√©s de los canales\n- Se logra mediante un sistema de derechos de acceso y distintos tipos de autoridad\n\n## Principal\nAutoridad con la que se ordena cada invocaci√≥n de objetos o sus resultados\n- Se contrasta con los derechos de acceso de dicho objeto\n## Modelo de enemigo\n### Entidad\nCualquier m√°quina conectada( de forma autorizada o no) a la red \n### Enemigo \nEntidad capaz de:\n- Enviar cualquier mensaje a cualquier proceso\n- Leer o copiar cualquier mensaje compartido entre dos procesos\n- Leer mensajes o emitir mensajes falsos de petici√≥n de servicios.\n\n## Amenazas a servidores\nCiertos servicios no comprueban la identidad del cliente\n- Si la comprueban, no suele ser dif√≠cil suplantarla (spoofing)\n\nEn vez de una petici√≥n de servicio aut√©ntica se busca, p. ej., obtener informaci√≥n no autorizada o bloquear el servicio (DoS)\n\n## Amenazas a clientes\n- Reciben un resultado falso de la invocaci√≥n al servicio\n- Generalmente, acompa√±ado de suplantaci√≥n de identidad\n\n## Amenazas a canales de comunicaci√≥n\n- Inyecci√≥n, copia o alteraci√≥n de mensajes que viajan por el canal\n\nPor ejemplo: obtener un mensaje de transferencia de dinero, cambiar la cuenta y re enviarlo despu√©s\n\n## T√©cnicas de seguridad\n- Autenticaci√≥n: Comprobaci√≥n de la identidad del proceso\n- Criptograf√≠a: Uso de claves p√∫blicas y privadas\n- Canales seguros: Canal de comunicaci√≥n sobre el que dos procesos han establecido una capa de seguridad basada en criptograf√≠a + autenticaci√≥n:\n\t- Se garantiza la identidad fiable de servidores y clientes\n\t- Se garantiza la integridad y privacidad de los mensajes enviados\n\t- Los mensajes incluyen una marca de tiempo para prevenir su repetici√≥n o reordenaci√≥n maliciosa\n","lastmodified":"2022-06-29T06:05:34.847071901Z","tags":null},"/Examen1/ModelosFundamentales":{"title":"","content":"# Modelos Fundamentales\nTodas las arquitecturas comparten algunas propiedades fundamentales: \nProcesos que se comunican por paso de mensajes a trav√©s de una red de computadores. \n- [[ModelosInteraccion]]: El modelo debe definir y clasificar la comunicaci√≥n entre elementos del sistema.\n- [[ModeloFallos]]: El modelo debe definir y clasificar los fallos que pueden darse en el sistema. \n- [[ModelosSeguridad]]: El modelo debe definir y clasificar los tipos de ataque que pueden afectar al sistema.\n\n\n\n","lastmodified":"2022-06-29T06:05:34.847071901Z","tags":null},"/Examen1/Quees":{"title":"","content":"# Sistemas Distribuidos\n## Que es\n**Conjunto de equipos independientes que act√∫an de forma transparente como un √∫nico equipo.**\n\nSu funci√≥n es la descentralizar el almacenamiento de la informaci√≥n o comput (BD-SERVIDORES). Tambi√©n puede definirse como una colecci√≥n de computadoras independientes, separadas f√≠sicamente, pero que aparentan ser un solo equipo realizando las m√∫ltiples tareas\n\n‚Ä¢ Se implementan en diversas plataformas de hardware y software. \n‚Ä¢ Todo se conecta por red.\n\n## Ventajas\n‚Ä¢ Eficacia. Uso racional de los recursos con que se cuenta para alcanzar un objetivo predeterminado. A mayor eficiencia menor la cantidad de recursos que se emplear√°n, logrando mejor optimizaci√≥n y rendimiento. \n‚Ä¢ Tolerancia a fallos. Permite que, en caso de que una computadora falle, otra la pueda sustituir en la realizaci√≥n de sus tareas asignadas. Al estar distribuida la informaci√≥n en nodos, en caso de que se caiga un nodo, dicha informaci√≥n va a encontrarse replicada en otros nodos. \n‚Ä¢ Mayor velocidad. Est√° en referencia a los tiempos de respuesta de una aplicaci√≥n; cuando se realiza una consulta, lo procesamientos se dividen entre todos los nodos que forman el sistema distribuido, en lugar de enviarlos a un √∫nico nodo y que el mismo tenga que hacer todo el trabajo. \n‚Ä¢ Procesamiento distribuido. Se puede definir como la forma en que es posible conectar distintas m√°quinas, logrando as√≠, que una sola tarea de procesamiento de datos pueda ser procesada o ejecutada entre varias m√°quinas de la red, es decir que un solo proceso se pueda realizar entre varias m√°quinas diferentes y conectadas a una red. \n‚Ä¢ Escalabilidad. Permite que a la arquitectura actual se le pueda adicionar m√°s poder de c√≥mputo. Se entiende por escalabilidad a la capacidad de adaptaci√≥n y respuesta de un sistema con respecto al rendimiento del mismo a medida que aumentan de forma significativa el n√∫mero de usuarios del mismo.\n\n## Desafios\n1. Seguridad. - Mantener la confidencialidad, integridad y disponibilidad de los recursos en la red. \n2. Concurrencia. - El sistema debe permitir m√∫ltiples usuarios utilizando simult√°neamente los recursos de la red. \n3. Extensibilidad. - Poder soportar nuevas funcionalidades o cambios en el sistema. \n4. Resiliencia (Tratamiento a fallos). - Un Sistema Distribuido debe poder detectar, ocultar y recuperarse de fallos que puedan ocurrir en la red. \n5. Escalabilidad. - El sistema debe mantener el rendimiento de los recursos cuando se aumenta el n√∫mero de usuarios (consumidores). \n6. Transparencia. - Para el usuario y/o el programador de aplicaciones el sistema debe ser percibido como un todo m√°s que como una colecci√≥n de recursos. \n7. Heterogeneidad. - Consiste en la capacidad de poder a√±adir o reemplazar los componentes de la red (lenguajes de programaci√≥n, sistemas operativos, protocolos, formatos, redes, hardware).","lastmodified":"2022-06-29T06:05:34.847071901Z","tags":null},"/Examen1/Raids":{"title":"","content":"# Raid\n## HDD vs SDD\n### HDD\nLos discos duros, tambi√©n conocidos como HDD, son un componente inform√°tico que sirve para almacenar de forma permanente tus datos. Esto quiere decir, que los datos no se borran cuando se apaga la unidad como pasa en los almacenados por la memoria RAM. La primera empresa en comercializarlos fue IBM en 1956. \n\nEst√°n compuestos de piezas mec√°nicas, de ah√≠ que a veces se le llame discos duros mec√°nicos, y utilizan el magnetismo para grabar tus datos y archivos. Se compone de uno o varios discos r√≠gidos unidos por un mismo eje y que giran a gran velocidad dentro de una caja met√°lica. En cada plato y en cada una de sus caras, un cabezal de lectura/escritura lee o graba tus datos sobre los discos\n\n### SDD\nLas unidades de estado s√≥lido o SSD (Solid State Drive) son una alternativa a los discos duros. La gran diferencia es que mientras los discos duros utilizan componentes mec√°nicos que se mueven, las SSD almacenan los archivos en microchips con memorias flash interconectadas entre s√≠. Por lo tanto, casi podr√≠amos considerarlos como una evoluci√≥n de las memorias USB. \n\nLos SSD suelen utilizar memorias flash basadas en NAND, que como tambi√©n son no-vol√°tiles mantienen la informaci√≥n almacenada cuando el disco se desconecta. No tienen cabezales f√≠sicos para grabar los datos, en su lugar incluyen un procesador integrado para realizar operaciones relacionadas con la lectura y escritura de datos.\n\n\n## Raid\nRAID es la sigla para \" Redundant Array of Independent Disks \". Su definici√≥n en espa√±ol ser√≠a \"Matriz Redundante de Discos Independientes \". Se trata de una tecnolog√≠a que combina varios discos r√≠gidos (HD) para formar una √∫nica unidad l√≥gica, donde los mismos datos son almacenados en todos los discos (redundancia). \n\nLa tecnolog√≠a RAID protege los datos contra el fallo de una unidad de disco duro. Si se produce un fallo, RAID mantiene el servidor activo y en funcionamiento hasta que se sustituya la unidad defectuosa. \n\nLa tecnolog√≠a RAID se utiliza tambi√©n con mucha frecuencia para mejorar el rendimiento de servidores y estaciones de trabajo. Estos dos objetivos, protecci√≥n de datos y mejora del rendimiento, no se excluyen entre s√≠.\n\n### Raid 0\nNo ofrece tolerancia a fallos, pero si mayor velocidad, algunos no consideran a esta configuraci√≥n como un RAID verdadero. Una configuraci√≥n RAID 0 con dos discos es hasta dos veces m√°s r√°pidas que un solo disco duro. **Se utiliza en entornos de laboratorio para medir las entradas y salidas de un sistema por su rapidez.**\n\n### Raid 1\nTambi√©n conocido como \"Mirroring \" o \" Espejado \", el RAID 1 funciona a√±adiendo discos r√≠gidos paralelos a los discos r√≠gidos principales existentes en la computadora. De esta manera, si, por ejemplo, una computadora posee 2 discos, se puede anexar un disco r√≠gido para cada uno, totalizando 4. **Los discos que fueron a√±adidos, trabajan como una copia del primero. **\n\nLa consecuencia en este caso, es que la grabaci√≥n de datos es m√°s lenta, pues es realizada dos veces. Sin embargo, la lectura de esa informaci√≥n es m√°s r√°pida, pues puede ser accedida de dos fuentes. **Se utiliza para el Sistema Operativo, debido a que es una copia tal cual, en caso de un fallo del mismo, es m√°s lento.**\n\n### Raid 5\nEste RAID ofrece tolerancia al fallo, pero adem√°s optimiza la capacidad del sistema permitiendo una utilizaci√≥n de hasta el 80% de la capacidad del conjunto de discos. Esto lo consigue mediante el c√°lculo de la informaci√≥n de paridad y su almacenamiento alternativo por bloques en todos lo discos del conjunto. La informaci√≥n del usuario se graba por bloques y de forma alternativa en todos ellos. Uso m√≠nimo de 3 discos. En resumen, el RAID 5 es un buen sistema integral que combina almacenamiento eficiente con excelente seguridad y rendimiento. **Es ideal para servidores de archivos y aplicaciones que tienen un n√∫mero limitado de unidades de datos.**\n\n### Raid 6\n**Acceso independiente con doble paridad**\nSimilar al RAID 5, pero incluye un segundo esquema de paridad distribuido por los distintos discos y por tanto ofrece tolerancia extremadamente alta a los fallos y a las ca√≠das de disco, ofreciendo dos niveles de redundancia. \n\nSi fallan m√°s de dos unidades de disco, los datos se tienen que restaurar a partir del medio de copia de seguridad. L√≥gicamente, la capacidad de dos unidades de disco est√° dedicada a almacenar datos de paridad en un conjunto de paridad. No obstante, en la pr√°ctica, los datos de paridad se reparten entre varias unidades de disco. \n\nEl n√∫mero m√≠nimo de unidades de disco en un conjunto de paridad es de 4. El n√∫mero m√°ximo de unidades de disco en un conjunto de paridad es de 18. RAID 6 permite almacenar grandes cantidades de datos a prueba de fallos a largo plazo al amortiguar dos posibles fallos. **Por tanto, los sistemas de servidores en los que se archivan datos son un caso de aplicaci√≥n ideal.**\n","lastmodified":"2022-06-29T06:05:34.847071901Z","tags":null},"/Examen1/TCP-UDP":{"title":"","content":"# TCP y UDP\n## TCP\nTCP (Protocolo de Control de Transmisi√≥n, por sus siglas en ingl√©s Transmission Control Protocol) es protocolo de red importante que permite que dos anfitriones (hosts) se conecten e intercambien flujos de datos. TCP garantiza la entrega de datos y paquetes (en-US) en el mismo orden en que se enviaron.\n\n## UDP\nEl Protocolo de datagrama de usuario (UDP) es un protocolo ligero de transporte de datos que funciona sobre IP. UDP proporciona un mecanismo para detectar datos corruptos en paquetes, pero no intenta resolver otros problemas que surgen con paquetes, como cuando se pierden o llegan fuera de orden.\n\n## Diferencias\n- Conexi√≥n: TCP es un protocolo orientado a la conexi√≥n mientras que UDP no utiliza conexi√≥n. TCP establece una conexi√≥n entre un remitente y un receptor antes de que se puedan enviar los datos. UDP en cambio, no establece ninguna conexi√≥n antes de enviar los datos. \n- Fiabilidad: TCP es confiable ya que garantiza que los datos enviados mediante el protocolo TCP se entreguen al receptor. Si los datos se pierden en el camino, los recuperar√° y los reenviar√°. TCP tambi√©n verifica los paquetes en busca de errores y los rastrea para que los datos no se pierdan ni se corrompan. En cambio, UDP no es confiable. Este no garantiza la entrega de los paquetes y los paquetes pueden corromperse o perderse en tr√°nsito. \n- Control de Flujo: TCP utiliza un mecanismo de control de flujo que garantiza que el remitente no sature al receptor enviando demasiados paquetes a la vez. Este, almacena los datos en un b√∫fer de env√≠o y los recibe en un b√∫fer de recepci√≥n. Cuando la aplicaci√≥n est√° lista, lee los datos del b√∫fer de recepci√≥n. Si el b√∫fer de recepci√≥n est√° lleno, el receptor no puede manejar m√°s datos y los elimina. Cada vez que el receptor recibe un paquete, env√≠a un mensaje al remitente. UDP, no proporciona control de flujo. Con UDP, los paquetes llegan de forma continua o se descartan. \n- Ordenaci√≥n: TCP ordena los paquetes para garantizar que se entreguen al cliente en el mismo orden en que se enviaron. En cambio, UDP env√≠a los paquetes sin importar el orden. \n- Velocidad: Otra diferencia entre TCP y UDP, es que TCP es m√°s lento, porque hace mucho m√°s que enviar datos. TCP establece una conexi√≥n, verifica los errores y garantiza que los archivos se reciban en el orden en que fueron enviados tal y como hemos comentado anteriormente. Por lo tanto, la velocidad es uno de los aspectos en los que destaca UDP. \n\n- Uso: TCP es el protocolo m√°s adecuado para usarse en aplicaciones que requieren una alta confiabilidad.\n\t- P√°ginas web (HTTP, HTTPS) \n\t- Correo electr√≥nico (SMTP, IMAP/POP) \n\t- SSH \n\t- FTP\n- UDP es m√°s adecuado para aplicaciones que requieren velocidad y eficiencia.\n\t- VPN \n\t- Juegos online \n\t- Videos en directo\n\t- DNS \n\t- Voz a trav√©s de internet (VoIP) \n\t- TFTP","lastmodified":"2022-06-29T06:05:34.847071901Z","tags":null},"/Examen2/CAP":{"title":"ü™¥ Teorema CAP","content":"El Teorema CAP indica que los sistema distribuido de almacenamiento de datos pueden llegar a ser vulnerables a fallos por conectividad en la red, es por esto que indica que estos sistemas solo pueden llegar a tener dos de los tres siguientes atributos:\n-   Consistencia: Este atributo quiere decir que sin importar el lugar o la instancia del servicio que se est√© usando, este siempre tiene que ser el mismo, por ejemplo las bases de datos SQL quieren lograr esto por lo que existe diferentes m√©todos y restricciones para lograrlo, en MYSQL existen las transacciones que garantiza esto y tambi√©n el comando LOCK TABLE para evitar que otro usuario lea esta base de datos mientras otro la escribe, con el fin de evitar lecturas sucias.\n-   Disponibilidad: Esto quiere decir que la respuesta ser√° v√°lida y se deber√° dar en un tiempo razonable, es decir que no tarde m√°s de lo debido. Esto es importante si lo que se quiere es obtener los datos de manera r√°pida y garantizar que se obtendr√°n como es el caso de las bases de datos SQL.\n-   Tolerancia a particiones: Esto quiere decir que el sistema debe permanecer estable aun cuando algunos nodos no se encuentren disponibles, ya que se supone que el resto de los nodos tienen la informaci√≥n de manera consistente.\n    \n\nAhora como se mencion√≥ anteriormente este teorema dice que solo se puede garantizar dos de estos tres atributos creando combinaciones entre ellos, por ejemplo tener Consistencia y disponibilidad como es el caso de las bases de datos SQL, tener disponibilidad y tolerancia a particiones o tener consistencia y tolerancia a particiones.\n\nEjemplos:\n\n- CA : MySQL, Postgres, Aster Data, Greenpium, Vertica.\n\n- AP: SimpleDB, CouchDB, Cassandra, Riak, Dynamo, [Voldemort](https://www.project-voldemort.com/voldemort/)\n\n- CP: MongoDB, Terrastore, Scalaris, Berkeley DB, MemcacheDB.\n","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/Examen2/DNS":{"title":"ü™¥ DNS","content":" Una base de datos jer√°rquica y distribuida que almacena nombres de dominios y su relaci√≥n a otra informaci√≥n como IP‚Äôs\n    \n## Jerarqu√≠a\n- Root\n-  Nivel Superior (net,com,org)\n- Segundo Nivel (nombre)\n- Subdominio\n\n## Fully Qualified Domain Name FQDN \nEs la ruta completa de una p√°gina o recurso en internet con respecto a toda la jerarqu√≠a.\n- Consulta Recursiva: Se tiene la informaci√≥n del recurso en el servidor y el mismo logra proveer una respuesta\n- Consulta Iterativa: El servidor tiene que buscar el recurso externamente y una vez que lo encuentra lo guarda en su cache y devuelva la respuesta (outsourcing)\n- Reenviadores: b√°sicamente un servidor mucho m√°s r√°pido y con m√°s memoria para resolver requests mucho m√°s eficientemente¬†\n    \n## Registro de recursos:\n - A: Resuelve un nombre de host a una IP\n - Ptr: Resuelve IP a un host name\n - Mx: Servidor de correo\n - Ns: identifica el servidor de dns para cada zona","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/Examen2/Exclusion":{"title":"ü™¥ Secci√≥n cr√≠tica","content":"Existen m√∫ltiples caracter√≠sticas que un sistema distribuido debe de cumplir, como:\n- confiabilidad\n- disponibilidad\n- apertura\n- integridad de informaci√≥n\n\nDentro de la integridad de informaci√≥n, un problema relevante son las condiciones de competencia que se generan al tener recursos compartidos. Por esta raz√≥n, el tema de la **exclusi√≥n mutua** se vuelve de sumo inter√©s. \n\nEste problema debe de ser resuelto para asegurar el acceso de forma correcta a los recursos compartidos, con la finalidad de mantener la integridad y consistencia en los datos.\n\n## Deadlock\nCada proceso debe de pedir permiso para poder entrar en la regi√≥n cr√≠tica y debe de liberarla despu√©s de haberla ocupado en su ejecuci√≥n, para permitir, a otro proceso, entrar a la regi√≥n cr√≠tica. Un algoritmo de exclusi√≥n mutua se define como el mecanismo\n\nPara poder asegurar que solo un proceso est√© en la regi√≥n cr√≠tica, debe de asegurar que no existan deadlocks.\n\nUn Deadlock (tambi√©n llamado \"bloqueo mutuo\", \"abrazo mortal\", ‚Äúpunto muerto\", etc.) sucede cuando dos o m√°s transacciones intentan hacer bloqueos de claves en orden opuesto, por ejemplo:\n\n\n## Secci√≥n cr√≠tica (secci√≥n cr√≠tica y regi√≥n cr√≠tica son denominaciones equivalentes) \nEn programaci√≥n concurrente de ciencias de la computaci√≥n, a la porci√≥n de c√≥digo de un programa de ordenador en la que se accede a un recurso compartido (estructura de datos o dispositivo) que no debe ser accedido por m√°s de un proceso o hilo en ejecuci√≥n. \n\nLa secci√≥n cr√≠tica por lo general termina en un tiempo determinado y el hilo, proceso o tarea √∫nicamente tendr√° que esperar un per√≠odo determinado de tiempo para entrar. Se necesita un mecanismo de sincronizaci√≥n en la entrada y salida de la secci√≥n cr√≠tica para asegurar la utilizaci√≥n en exclusiva del recurso, por ejemplo un sem√°foro, monitores, el algoritmo de Dekker y Peterson, los candados.\n\n## Requisitos \nSe denomina regi√≥n cr√≠tica, (secci√≥n cr√≠tica y regi√≥n cr√≠tica son denominaciones equivalentes) en programaci√≥n concurrente de ciencias de la computaci√≥n, a la porci√≥n de c√≥digo de un programa de ordenador en la que se accede a un recurso compartido (estructura de datos o dispositivo) que no debe ser accedido por m√°s de un proceso o hilo en ejecuci√≥n.\n\nProceso entra a ejecutar una secci√≥n cr√≠tica en al que accede a unas variables compartidas, entonces otro proceso no puede entrar a ejecutar una secci√≥n cr√≠tica\nLas secciones cr√≠ticas se pueden agrupar en clases, siendo mutuamente exclusivas.\n\nSe debe implementar protocolos de software que impidan o bloqueen en acceso a una secci√≥n cr√≠tica.\n\n## Exclusi√≥n mutua distribuida\nDicho problema es conocido como el problema de la secci√≥n cr√≠tica en el dominio de los SO. En los sistemas distribuidos se requiere una soluci√≥n que est√© basada exclusivamente en el paso de mensajes.\n\n### Requisitos\nLos requisitos esenciales para la exclusi√≥n mutua son:\n- EM1 (seguridad): a lo sumo un proceso puede estar ejecut√°ndose una vez en la secci√≥n cr√≠tica.\n- EM2 (superveniencia): las peticiones para entrar y salir de la secci√≥n cr√≠tica al final deben ser concedidas. Esto implica la inexistencia de deadlocks e inanici√≥n.\n- EM3 (ordenaci√≥n): si una petici√≥n parar entrar en la SC ocurri√≥ antes que otra, entonces la entrada en la SC se garantiza en ese orden.\n\n### Mecanismos para garantizar la exclusi√≥n mutua\n##### Sem√°foros\nM√©todo cl√°sico para restringir o permitir el acceso a recursos compartidos (por ejemplo, un recurso de almacenamiento del sistema o variables del c√≥digo fuente) en un entorno de multiprocesamiento\n\nUn tipo simple de sem√°foro es el binario, que puede tomar solamente los valores 0 y 1. Se inicializan en 1 y son usados cuando solo un proceso puede acceder a un recurso a la vez\n\nControla los procesos dentro de memoria en el √°rea de datos compartidos (lectura, lectura/escritura, escritura).\n\nTrabaja con dos elementos:\n- se√±al (despertar)\n- espera (dormir)\n\nDependiendo del tipo de operaci√≥n en el √°rea de datos compartidos, ser√° el sem√°foro que se implante.\n\nEl uso de sem√°foros depende del n√∫mero de procesos; en √°reas de datos no compartidos no tiene raz√≥n de ser.\n\nCuando cualquier proceso accede a los recursos compartidos, realiza la operaci√≥n wait() en el sem√°foro y cuando el proceso libera los recursos compartidos, realiza la operaci√≥n signal() en el sem√°foro. El sem√°foro no tiene variables de condici√≥n. \n\nCuando un proceso est√° modificando el valor del sem√°foro, ning√∫n otro proceso puede modificar simult√°neamente el valor del sem√°foro.\n\n\n#### Monitores\nun monitor es un programa que observa y administra los procesos dentro del CPU.\n\nSe pueden implementar monitores en memoria en √°reas de datos compartidos y no compartidos.\n\nUn monitor contiene el c√≥digo relativo a un recurso compartido en un solo m√≥dulo de programa\n\nLa interfaz del monitor es un conjunto de funciones que representan las diferentes operaciones que pueden hacerse con el recurso.\n\nUna construcci√≥n de sincronizaci√≥n de alto nivel de tipo Monitor. Es un tipo de datos abstracto. El tipo Monitor contiene variables compartidas y el conjunto de procedimientos que operan en la variable compartida.\n\nCuando cualquier proceso desea acceder a las variables compartidas en el monitor, necesita acceder a ellas a trav√©s de los procedimientos. Estos procesos se alinean en una cola y solo se les proporciona acceso cuando el proceso anterior libera las variables compartidas. √önicamente un proceso puede estar activo en un monitor a la vez. El monitor tiene variables de condici√≥n.\n\n##### Ventajas:\n‚Ä¢ Mantenimiento m√°s simple\n‚Ä¢ Menos errores de programaci√≥n\n\n### Monitores vs Semaforos\n#### Ventajas monitores\n- Los monitores son f√°ciles de implementar que los sem√°foros.\n- La exclusi√≥n mutua en los monitores es autom√°tica, mientras que en los sem√°foros, la exclusi√≥n mutua debe implementarse expl√≠citamente.\n- Los monitores pueden superar los errores de sincronizaci√≥n que se producen al utilizar sem√°foros.\n- Las variables compartidas son globales para todos los procesos en el monitor, mientras que las variables compartidas est√°n ocultas en sem√°foros.\n\n#### Ventajas semaforos\n- Los sem√°foros son independientes de la m√°quina (porque est√°n implementados en los servicios del kernel).\n- Los sem√°foros permiten que m√°s de un hilo acceda a la secci√≥n cr√≠tica, a diferencia de los monitores.\n- En los sem√°foros no hay desperdicio de recursos debido a que no hay esperas ocupadas.\n\n### Algoritmo de Dekker\nEs un algoritmo de programaci√≥n concurrente para exclusi√≥n mutua, que permite a dos procesos o hilos de ejecuci√≥n compartir un recurso sin conflictos si ambos procesos intentan acceder a la secci√≥n cr√≠tica simult√°neamente, el algoritmo elige un proceso seg√∫n una variable turno. Si el otro proceso est√° ejecutando en su secci√≥n cr√≠tica, deber√° esperar su finalizaci√≥n.\n\nExisten cinco versiones del algoritmo Dekker, teniendo ciertos fallos los primeros cuatro. **La versi√≥n 5 es la que trabaja m√°s eficientemente, siendo una combinaci√≥n de la 1 y la 4.**\n\n1. Versi√≥n 1: Alternancia estricta. Garantiza la exclusi√≥n mutua, pero su desventaja es que acopla los procesos fuertemente, esto significa que los procesos lentos atrasan a los procesos r√°pidos.\n2. Versi√≥n 2: Problema interbloqueo. No existe la alternancia, aunque ambos procesos caen a un mismo estado y nunca salen de ah√≠.\n3. Versi√≥n 3: Colisi√≥n regi√≥n cr√≠tica no garantiza la exclusi√≥n mutua. Este algoritmo no evita que dos procesos puedan acceder al mismo tiempo a la regi√≥n cr√≠tica.\n4. Versi√≥n 4: Postergaci√≥n indefinida. Aunque los procesos no est√°n en interbloqueo, un proceso o varios se quedan esperando a que suceda un evento que tal vez nunca suceda.\n\n### Algoritmo Petterson\nAlgoritmo de programaci√≥n concurrente para exclusi√≥n mutua, que permite a dos o m√°s procesos o hilos de ejecuci√≥n compartir un recurso sin conflictos, utilizando solo memoria compartida para la comunicaci√≥n \nCada proceso tiene un turno para entrar en la secci√≥n cr√≠tica, di desea entrar debe activar su se√±al y puede que tenga que esperar a que llegue su turno\n- Version simplificada del algoritmo de Dekker\n\n\n\n","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/Examen2/Hipervisores":{"title":"ü™¥ Hipervisores","content":"\nSoftware que permite la virtualizaci√≥n\n\n-   Tipo 1: se instala directamente y corre en el hardware\n    \n-   Tipo 2: corre a partir de un sistema operativo","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/Examen2/LVM":{"title":"ü™¥ LVM","content":"\nSistema de administraci√≥n de una colecci√≥n de unidades de almacenamiento, divididas l√≥gicamente para su f√°cil uso y extensi√≥n.\n    \n-   Permite realizar operaciones en caliente (mover discos, expandir, tomar snapshots) sin tener que parar el sistema.\n    \n-   Puede ser m√°s complicada de setup y se puede perder toda la informaci√≥n si una unidad falla\n    \n## Physical Volume PV \nEs cualquier dispositivo f√≠sico que pueda almacenar datos. De estos dispositivos parte el LVM\n    \n## Volume Group \nEs un grupo de PV‚Äôs\n\n## Logical Volume \nLa divisi√≥n l√≥gica de todo el VG. (Si se tiene 2 discos de 1 Gb cada uno en un VG, podemos asignar el uso de 1.5Gb en total de todo el VG)\n","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/Examen2/Relojes":{"title":"ü™¥ Relojes","content":"\nExisten 2 tipos de relojes:\n- Relojes F√≠sicos\nAquellos que est√°n directamente relacionados con el tiempo real y la concepci√≥n que tenemos de este.\n- Relojes L√≥gico\nAquellos que tienen como importancia el orden de los eventos.\n\nLas computadoras tienen por lo general un reloj f√≠sico de cuarzo que basa su medici√≥n de tiempo en las oscilaciones del cristal. \n\nLas oscilaciones de los cristales pueden ser de diferentes velocidades lo que generar√≠a un sesgo de reloj, lo que quiere decir que los relojes de 2 dispositivos se encuentran desincronizados. \n\nPara evitar que los relojes dentro de un sistema se encuentren desincronizados, es necesario implementar algoritmos o protocolos de sincronizaci√≥n. \n## Categoria de algoritmos\nDentro de los algoritmos podemos definir 4 categor√≠as:\n- Internos: La sincronizaci√≥n sucede dentro de la red.\n- Externos: Se hace la petici√≥n de la hora a un servidor externo confiable.\n- Pasivos: Los nodos piden la hora.\n- Activos: El servidor o el maestro de la hora pregunta por las horas de los dem√°s y env√≠a instrucciones.\n\n## Algoritmos\n### Algoritmo de christian\nEste algoritmo propone tener un servidor externo UTC al que los nodos del sistema preguntar√°n la hora para poder sincronizar los relojes.\n\nHay que tomar ciertas consideraciones en cuenta al momento de usar este algoritmo:\n#### Ventajas\n- Los relojes no deben retroceder para evitar errores\n- La sincronizaci√≥n requiere del intercambio de mensajes, pero el tr√°nsito de estos consume tiempo.\n- El tiempo del receptor UTC no puede ser menor que el tiempo de la m√°quina que le solicit√≥ el tiempo.\n- El servidor de UTC debe procesar las solicitudes de tiempo con el concepto de interrupciones, lo cual incide en el tiempo de atenci√≥n.\n- El intervalo de transmisi√≥n de la solicitud y su respuesta debe ser tomado en cuenta para la sincronizaci√≥n.\n- El tiempo de propagaci√≥n se suma al tiempo del servidor para sincronizar al emisor cuando √©ste recibe la respuesta.\n##### Inconvenientes\n- El problema que se presenta es la posibilidad de fallo debido a la existencia de un √∫nico servidor. Cristian sugiere m√∫ltiples servidores de tiempo sincronizados que suministren el tiempo. El cliente env√≠a un mensaje de petici√≥n a todos los servidores y toma la primera respuesta recibida.\n- El algoritmo no contempla problemas de malfuncionamiento o fraude por parte del servidor.\n- La capacidad de cada nodo para leer el valor del reloj de otro nodo puede generar errores debido al retraso en la comunicaci√≥n de mensajes entre nodos. La demora se puede calcular tomando en cuenta el tiempo necesario para preparar, transmitir y recibir un mensaje vac√≠o en ausencia de errores de transmisi√≥n y carga del sistema.\n### Algoritmo de Berkeley \nEste algoritmo se propone en situaciones en las que no se cuenta con un servidor UTC confiable. La idea es que dentro de las computadoras de una red, se selecciona una que sea maestra y las dem√°s ser√°n esclavas. Esta computadora maestra, se encargar√° de preguntarle a las dem√°s las horas que est√°n manejando, para poder sacar un promedio y mandar instrucciones para el retraso o adelanto de relojes dependiendo la situaci√≥n de cada computadora. \n\nEn este algoritmo no es importante tener en cuenta el delay entre el env√≠o y respuesta del mensaje debido a que solo necesitamos hallar un promedio para la sincronizaci√≥n, m√°s no la hora exacta. En caso de que el maestro muera, se busca uno nuevo, y si un nodo falla, simplemente no se toma en cuenta. \n##### Inconvenientes\n- En caso de que el maestro falle, dejar√° de preguntar la hora y, en consecuencia, se perder√° la sincronizaci√≥n.\n- En el paso de mensajes entre maestro y esclavos y vicerversa se ha de tener en cuenta el retraso que genera el propio env√≠o de los mensajes por lo que tendremos errores a la hora de sincronizar.\n- Otro de los problemas de ser un algoritmo centralizado ser√° el de tener que elegir un nuevo maestro debido a que se puedan producir fallos en el tratamiento de los datos para llevar a cabo la sincronizaci√≥n, buscando un maestro que cometa menor cantidad de fallos y el sistema se mantenga en correcto funcionamiento.\n- La demora introducida por los equipos de conmutaci√≥n, se agrava en los casos en los que el equipo cumple otras funciones adem√°s de conmutar paquetes, como es el caso de un PC que, adem√°s de actuar como conmutador, atiende otras tareas, con lo cual, la misma tarea de conmutar puede insumir diferentes tiempos.\n## NTP\nFinalmente nos encontramos con el protocolo NTP para la sincronizaci√≥n de relojes mediante internet. Este protocolo funciona en la capa 4 de red, con el protocolo UDP y en el puerto 123.\n\n### Funcionamiento\nEl cliente NTP inicia un intercambio de solicitud de tiempo con el servidor NTP. Luego, el cliente puede calcular el retraso del enlace y su compensaci√≥n local y ajustar su reloj local para que coincida con el reloj de la computadora del servidor.\n\nComo regla general, se requieren seis intercambios durante un per√≠odo de aproximadamente cinco a 10 minutos para configurar inicialmente el reloj.\n\nUna vez sincronizado, el cliente actualiza el reloj aproximadamente una vez cada 10 minutos, lo que generalmente requiere solo un √∫nico intercambio de mensajes, adem√°s de la sincronizaci√≥n cliente-servidor. Esta transacci√≥n ocurre a trav√©s del Protocolo de datagramas de usuario (UDP) en el **puerto 123** NTP tambi√©n admite la sincronizaci√≥n de transmisi√≥n de los relojes de la computadora del mismo nivel.\n\nHay miles de servidores NTP en todo el mundo. Tienen acceso a relojes at√≥micos de alta precisi√≥n y relojes del Sistema de Posicionamiento Global. Se requieren receptores especializados para comunicarse directamente con los servidores NTP para estos servicios de tiempo. \n\nNo es pr√°ctico ni rentable equipar cada computadora con uno de estos receptores. En cambio, las computadoras designadas como servidores de tiempo principales est√°n equipadas con los receptores. Utilizan protocolos como NTP para sincronizar las horas de reloj de las computadoras en red.\n\nNTP utiliza el tiempo universal coordinado (UTC) para sincronizar las horas del reloj de la computadora con extrema precisi√≥n. Ofrece una mayor precisi√≥n en redes m√°s peque√±as, hasta 1 milisegundo en una red de √°rea local (LAN) y dentro de decenas de milisegundos en Internet. NTP no tiene en cuenta las zonas horarias. En cambio, depende del host para realizar tales c√°lculos.\n\nLos grados de separaci√≥n de la fuente UTC se definen como estratos. Los diversos estratos incluyen lo siguiente:\n- Estrato 0. Un reloj de referencia recibe la hora real de un transmisor dedicado o un sistema de navegaci√≥n por sat√©lite. Se clasifica como estrato 0.\n- Estrato 1. Un dispositivo est√° directamente vinculado al reloj de referencia.\n- Estrato 2. Un dispositivo recibe su tiempo de una computadora de estrato 1.\n- Estrato 3. Un dispositivo recibe su tiempo de una computadora de estrato 2.\n\nLa clasificaci√≥n de estrato contin√∫a a partir de ah√≠. La precisi√≥n se reduce con cada grado adicional de separaci√≥n.\n","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/Examen2/Seguridad":{"title":"ü™¥ Seguridad","content":"## DES 56 bit\nDES es el nombre del documento FIPS (Federal Information Processing Standard), es un algoritmo de cifrado por bloques de 64 bits de tama√±o. Emplea una clave de 56 bits durante la ejecuci√≥n.\n- Cuando se utiliza en comunicaciones ambos participantes deben conocer la clave secreta¬†\n- El algoritmo se puede usar para encriptar y desencriptar mensajes,¬†\n- Puede generar y verificar c√≥digos de autentificaci√≥n de mensajes\n- El problema principal es que el tama√±o de la clave (56 bits) es demasiado peque√±o para la potencia de c√°lculo actual. De hecho, el DES dej√≥ de ser el algoritmo empleado por el gobierno norteamericano en Noviembre de 1998 y de momento (hasta que el AES sea elegido), emplean el Triple DES\n\n## 3DES\nConsiste en encriptar tres veces una clave DES:\n- DES-EEE3: Tres encriptaciones DES con tres claves distintas.\n\n- Diffie y Hellman propusieron una m√°quina con un coste estimado de 20 millones de d√≥lares que podr√≠a encontrar una clave DES en un solo d√≠a.\n- Wiener propuso una m√°quina de b√∫squeda de claves con un coste de un mill√≥n de d√≥lares que encontrar√≠a una clave en 7 horas.\n\n## RSA\n- El algoritmo asim√©trico por excelencia\n- Este algoritmo se basa en la pareja de claves\n- La seguridad de este algoritmo radica en el problema de la factorizaci√≥n de n√∫meros enteros muy grandes\n- Actualmente como m√≠nimo se debe utilizar una longitud de 2048 bits, aunque es recomendable que sea de 4096 bits o superior para tener una mayor seguridad.\n- El sistema RSA permite longitudes variables, siendo aconsejable actualmente el uso de claves de no menos de 1024 bits (se han roto claves de hasta 512 bits, aunque se necesitaron m√°s de 5 meses y casi 300 ordenadores trabajando juntos para hacerlo).\n\nEl cifrado RSA funciona bajo la premisa de que el algoritmo es f√°cil de calcular en una direcci√≥n, pero casi imposible en sentido inverso. Como ejemplo, si te dijeran que 701.111 es un producto de dos n√∫meros primos, ¬øser√≠as capaces de averiguar cu√°les son esos dos n√∫meros?\n\n-   en RSA de **2048 bits, se unir√≠an para crear claves de 617 d√≠gitos**\n\n## DIFFIE HELLMAN\nSe usa para generar una clave privada a ambos extremos de un canal de comunicaci√≥n inseguro.\n- Se emplea para obtener la clave privada con la que posteriormente se cifrar√° la informaci√≥n junto con un algoritmo de cifrado sim√©trico.¬†\n- No es un algoritmo asim√©trico propiamente dicho, es un protocolo de establecimiento de claves\n- Su seguridad radica en la dificultad de calcular el logaritmo discreto de n√∫meros grandes\n- El problema de este algoritmo es que no proporciona autenticaci√≥n, no puede validar la identidad de los usuarios, por tanto, si un tercer usuario se pone en medio de la comunicaci√≥n, tambi√©n se le facilitar√≠a las claves y, por tanto, podr√≠a establecer comunicaciones con el emisor y el receptor suplantando las identidades.¬†\n- Certificaciones digitales\n\n## TLS\nTLS se traduce a Transport Layer Security o en espa√±ol Seguridad de la¬†Capa de Transporte y su sucesor SSL¬†\n-   TLS provee una comunicaci√≥n segura entre los navegadores de internet y los servidores. La conexi√≥n en s√≠, es segura gracias a que se usa una criptograf√≠a segura para encriptar los datos transmitidos.\n-   Las llaves son generadas de forma √∫nica por cada conexi√≥n y se basan en un secreto compartido negociado al comienzo de la sesi√≥n, tambi√©n conocido como ‚Äúsaludo de mano TLS‚Äù.\n-   Con la TLS 1.2, se hubieran requerido dos rondas de viaje para completar un saludo de mano TLS.\n-   Con el 1.3, requiere tan solo una ronda de viaje, la cual termina cortando hasta por la mitad la latencia de la encriptaci√≥n.\n\n## HASH\nEs un algoritmo matem√°tico que transforma cualquier bloque arbitrario de datos en una nueva serie de caracteres con una longitud fija.\n-   Independientemente de la longitud de los datos de entrada, el valor hash de salida tendr√° siempre la misma longitud.\n-   no existen dos entradas que produzcan el mismo hash de salida\n- Se utilizan las funciones criptogr√°ficas hash para detectar malware\n- Las funciones criptogr√°ficas hash se utilizan tambi√©n para asegurar la ‚Äúintegridad de los mensajes\n- gesti√≥n de los identificadores y contrase√±as\n","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/Examen2/Tansacciones":{"title":"ü™¥ Transacciones","content":"\nUna transacci√≥n es la ejecuci√≥n consistente y confiable de un conjunto de operaciones agrupadas como una unidad que acceden a una base de datos compartida\n\nUna transacci√≥n es una secuencia de una o m√°s operaciones agrupadas como una unidad\n\n## Operaciones at√≥micas\nLas operaciones at√≥micas en programaci√≥n concurrente son operaciones de programa que se ejecutan de forma completamente independiente de cualquier otro proceso.\n\nLas operaciones at√≥micas se utilizan a menudo en el kernel, el componente principal de la mayor√≠a de los sistemas operativos. Sin embargo, la mayor parte del hardware, los compiladores y las bibliotecas de las computadoras tambi√©n proporcionan distintos niveles de operaciones at√≥micas.\n    \n-   Se dice que una operaci√≥n es at√≥mica cuando se completa de principio a fin sin interrupciones.\n\n-   Java garantiza que son at√≥micos los accesos a las variables de tipos primitivos, excepto double y long\n\nLas operaciones que contiene una transacci√≥n se van almacenando temporalmente, no a nivel de disco. Es hasta que termina la transacci√≥n que se tienen efecto de manera permanente o no\n\nEn algunas situaciones, el cliente necesita que una secuencia de solicitudes al servidor se ejecuten de manera at√≥mica:\n\n- Libres de interferencia por operaciones de otros clientes\n- Todas las operaciones se deben completar con √©xito o no tener ning√∫n efecto si el servidor falla.\n\n### Caracter√≠sticas\n- El manejo de transacciones puede venir como parte del middleware que proporciona la especificaci√≥n para un servicio de transacciones sobre objetos.\n- Una transacci√≥n aplica a datos recuperables, puede estar formada por operaciones simples o compuestas y su intenci√≥n es que sea at√≥mica.\n- Hay dos aspectos que se deben cumplir para lograr la atomicidad: todo-o-nada, aislamiento.\n- Una transacci√≥n siempre termina, aun en la presencia de fallas. Si una transacci√≥n termina de manera exitosa se dice que la transacci√≥n hace un commit.\n- Cuando la transacci√≥n es abortada, su ejecuci√≥n se detiene y todas las acciones ejecutadas hasta el momento se deshacen (undone) regresando a la base de datos al estado antes de su ejecuci√≥n. **rollback**\n\n## Propiedades de las transacciones ACID\n1. Atomicidad **atomicity**\n2. Consistencia **consistency**\n3. Aislamiento **isolation**\n4. Durabilidad **durability**\n\n### Atomicidad\nAseguran que todas las operaciones dentro de la secuencia de trabajo se completen satisfactoriamente. Si no es as√≠, la transacci√≥n se abandona en el punto del error y las operaciones previas retroceden a su estado inicial.\n**TODO O NADA**\n\n### Consistencia\nAseguran que la base de datos cambie estados en una transacci√≥n exitosa.\n\n#### Aislamiento\nPermiten que las operaciones sean aisladas y transparentes unas de otras. **Sin interferencias**\n\n### Durabilidad\nUna vez que una transacci√≥n se completa correctamente, sus efectos no se pueden modificar sin ejecutar una transacci√≥n de compensaci√≥n. Los cambios realizados por una transacci√≥n correcta sobreviven a posteriores anomal√≠as del sistema.\n\n## Tipos\n### Planas\nEstas transacciones tienen un punto de partida simple **Begin** y **End**\n\n### Anidadas\n- Las operaciones de una transacci√≥n anidada pueden incluir otras transacciones.\n\n- Una transacci√≥n anidada dentro de otra transacci√≥n conserva las mismas propiedades que la de sus padres, esto implica, que puede contener as√≠ mismo transacciones dentro de ella.\n#### Restricciones de las anidadas\n- Debe empezar despu√©s que su padre y debe terminar antes que √©l.\n- El commit de una transacci√≥n padre est√° condicionada al commit de sus transacciones hijas\n- Si alguna transacci√≥n hija aborta (rollback), la transacci√≥n padre tambi√©n ser√° abortada (rollback).\n### Bit√°cora\n- Es un archivo que permite deshacer las operaciones realizadas sobre una o varias bases de datos en caso de que falle la transacci√≥n.\n- Esto se hace con el fin de mantener la integridad de la informaci√≥n y que la transacci√≥n sea at√≥mica\n\n## Seguridad en transacciones\n1. Autenticaci√≥n: asegura la identidad del servidor participante en la comunicaci√≥n.\n2. Confidencialidad: asegura que la informaci√≥n transmitida en la comunicaci√≥n entre el cliente y el servidor s√≥lo sea legible por estas dos entidades.\n3. Integridad: asegura que la informaci√≥n transmitida en la comunicaci√≥n entre el cliente y el servidor no haya sido alterada en su viaje por la red\n\nSSL ‚Äì SECURE SOCKET LAYER\nSET ‚Äì SECURE ELECTRONIC TRANSACTION \n\tEs un sistema que garantiza la seguridad e integridad \n     de las transacciones electr√≥nicas realizadas en un escenario. \n     SET no es un sistema que permita el pago, pero es un protocolo de seguridad aplicado a esos pagos. Utiliza diferentes t√©cnicas de encriptaci√≥n y hash para asegurar los pagos a trav√©s de Internet a trav√©s de tarjetas de cr√©dito. Este protocolo fue apoyado en el desarrollo por las principales organizaciones como Visa, Mastercard.\n","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/Examen2/VPNIPsec":{"title":"ü™¥ VPN IPsec","content":"## VPN\nUna red privada virtual (VPN por sus siglas en ingl√©s) es una tecnolog√≠a que permite a los usuarios enviar y recibir datos a trav√©s de redes compartidas o p√∫blicas como si sus equipos inform√°ticos estuvieran conectados directamente a la red privada. \n\nUn protocolo de tunelizaci√≥n es un protocolo que encapsula en su datagrama otro paquete de datos completo que utiliza un protocolo de comunicaciones diferente. Esencialmente, crea un t√∫nel entre dos puntos de una red por el cual se puede transmitir de forma segura cualquier tipo de datos.\n\n## IPsec\nIPsec es un tipo de protocolo que ofrece un conjunto de est√°ndares para que se cree una conexi√≥n VPN. Este protocolo permite encriptar los paquetes que se env√≠an para que viaje por ese t√∫nel y llegue al otro punto de manera segura, este protocolo cubre los siguientes puntos:\n-   Autenticaci√≥n de origen de datos: Verifica si el origen de los paquetes son realmente el origen indicado.\n-   Integridad de los datos: Verifica si el paquete es exactamente igual a como salieron el origen.¬†\n-   Confidencialidad de los datos: Significa que oculto el contenido por un cifrado.\n-   Protecci√≥n de reproducci√≥n: Impide que los paquetes puedan ser interceptados y despu√©s volverlos a reproducir.\n-   Gesti√≥n automatizada de claves criptogr√°ficas y asociaciones de seguridad: Permite utilizar VPN sin configuraci√≥n manual o con muy poca.\n\n## Protocolos\nLos protocolos que usa para las cabeceras y para el cuerpo son los siguientes\n\n-   AH: protocolo de cabecera de autenticaci√≥n, ofrece protecci√≥n de reproducci√≥n, integridad de los datos y autenticaci√≥n del origen de los datos, pero este no ofrece confidencialidad por lo que los datos son enviados en texto plano.\n    \n-   ESP: Ofrece la confidencialidad de los datos que no ofrece AH y de tambi√©n puede ofrecer autenticaci√≥n del origen de los datos, protecci√≥n contra la reproducci√≥n y comprobaci√≥n de la integridad.\n\nEste protocolo implica cinco componentes principales:\n-   Protocolos de seguridad: Los datagramas son protegidos con los dos protocolos mencionados y explicados anteriormente.\n-   Base de datos de asociaciones de seguridad (SADB): Esta base de datos es la que asocia un protocolo de seguridad con la direcci√≥n de destino IP y un n√∫mero de √≠ndice. La base de datos garantiza que se pueda reconocer un paquete que llega a su destino debidamente protegido.\n-   Administraci√≥n de claves: La distribuci√≥n y generaci√≥n de claves para los algoritmos criptogr√°ficos y SPI\n-   Mecanismos de seguridad:Los algoritmos de cifrado y autenticaci√≥n que protegen los datos de los datagramas IP.\n-   Base de datos de directivas de seguridad (SPD): Esta base de datos especifica el nivel de protecci√≥n que se aplicar√° a un paquete, este filtra el tr√°fico IP para que se pueda hallar el modo en el que se procesaran los paquetes.\n\n## Fases\nLas negociaciones IPsec se dan en dos fases: \n- Fase 1, en esta fase se crea un canal seguro para negociar la asociaci√≥n de seguridad IPsec(SA) \n- Fase 2, los participantes negocian este SA para la autenticaci√≥n del tr√°fico que pasa en este t√∫nel.","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/cheatsheet":{"title":"","content":"# Markdown Cheat Sheet\n\nThanks for visiting [The Markdown Guide](https://www.markdownguide.org)!\n\nThis Markdown cheat sheet provides a quick overview of all the Markdown syntax elements. It can‚Äôt cover every edge case, so if you need more information about any of these elements, refer to the reference guides for [basic syntax](https://www.markdownguide.org/basic-syntax) and [extended syntax](https://www.markdownguide.org/extended-syntax).\n\n## Basic Syntax\n\nThese are the elements outlined in John Gruber‚Äôs original design document. All Markdown applications support these elements.\n\n### Heading\n\n# H1\n## H2\n### H3\n\n### Bold\n\n**bold text**\n\n### Italic\n\n*italicized text*\n\n### Blockquote\n\n\u003e blockquote\n\n### Ordered List\n\n1. First item\n2. Second item\n3. Third item\n\n### Unordered List\n\n- First item\n- Second item\n- Third item\n\n### Code\n\n`code`\n\n### Horizontal Rule\n\n---\n\n### Link\n\n[Markdown Guide](https://www.markdownguide.org)\n\n### Image\n\n![alt text](https://www.markdownguide.org/assets/images/tux.png)\n\n## Extended Syntax\n\nThese elements extend the basic syntax by adding additional features. Not all Markdown applications support these elements.\n\n### Table\n\n| Syntax | Description |\n| ----------- | ----------- |\n| Header | Title |\n| Paragraph | Text |\n\n### Fenced Code Block\n\n```\n{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"age\": 25\n}\n```\n\n### Footnote\n\nHere's a sentence with a footnote. [^1]\n\n[^1]: This is the footnote.\n\n### Heading ID\n\n### My Great Heading {#custom-id}\n\n### Definition List\n\nterm\n: definition\n\n### Strikethrough\n\n~~The world is flat.~~\n\n### Task List\n\n- [x] Write the press release\n- [ ] Update the website\n- [ ] Contact the media\n\n### Emoji\n\nThat is so funny! :joy:\n\n(See also [Copying and Pasting Emoji](https://www.markdownguide.org/extended-syntax/#copying-and-pasting-emoji))\n\n### Highlight\n\nI need to highlight these ==very important words==.\n\n### Subscript\n\nH~2~O\n\n### Superscript\n\nX^2^","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/notes/CJK-+-Latex-Support-%E6%B5%8B%E8%AF%95":{"title":"CJK + Latex Support (ÊµãËØï)","content":"\n## Chinese, Japanese, Korean Support\nÂá†‰πéÂú®Êàë‰ª¨ÊÑèËØÜÂà∞‰πãÂâçÔºåÊàë‰ª¨Â∑≤ÁªèÁ¶ªÂºÄ‰∫ÜÂú∞Èù¢„ÄÇ\n\nÏö∞Î¶¨Í∞Ä Í∑∏Í≤ÉÏùÑ ÏïåÍ∏∞ÎèÑ Ï†ÑÏóê Ïö∞Î¶¨Îäî ÎïÖÏùÑ Îñ†ÎÇ¨ÏäµÎãàÎã§.\n\nÁßÅ„Åü„Å°„Åå„Åù„Çå„ÇíÁü•„Çã„Åª„ÅºÂâç„Å´„ÄÅÁßÅ„Åü„Å°„ÅØÂú∞Èù¢„ÇíÈõ¢„Çå„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ\n\n## Latex\n\nBlock math works with two dollar signs `$$...$$`\n\n$$f(x) = \\int_{-\\infty}^\\infty\n    f\\hat(\\xi),e^{2 \\pi i \\xi x}\n    \\,d\\xi$$\n\t\nInline math also works with single dollar signs `$...$`. For example, Euler's identity but inline: $e^{i\\pi} = 0$\n\nAligned equations work quite well:\n\n$$\n\\begin{aligned}\na \u0026= b + c \\\\ \u0026= e + f \\\\\n\\end{aligned}\n$$\n\nAnd matrices\n\n$$\n\\begin{bmatrix}\n1 \u0026 2 \u0026 3 \\\\\na \u0026 b \u0026 c\n\\end{bmatrix}\n$$\n\n## RTL\nMore information on configuring RTL languages like Arabic in the [config](notes/config.md) page.\n","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/notes/hosting":{"title":"Deploying Quartz to the Web","content":"\n## GitHub Pages\nQuartz is designed to be effortless to deploy. If you forked and cloned Quartz directly from the repository, everything should already be good to go! Follow the steps below.\n\n### Enable GitHub Actions\nBy default, GitHub disables workflows from running automatically on Forked Repostories. Head to the 'Actions' tab of your forked repository and Enable Workflows to setup deploying your Quartz site!\n\n![Enable GitHub Actions](notes/images/github-actions.png)*Enable GitHub Actions*\n\n### Enable GitHub Pages\n\nHead to the 'Settings' tab of your forked repository and go to the 'Pages' tab.\n\n1. (IMPORTANT) Set the source to deploy from `master` (and not `hugo`) using `/ (root)`\n2. Set a custom domain here if you have one!\n\n![Enable GitHub Pages](/notes/images/github-pages.png)*Enable GitHub Pages*\n\n### Pushing Changes\nTo see your changes on the internet, we need to push it them to GitHub. Quartz is a `git` repository so updating it is the same workflow as you would follow as if it were just a regular software project.\n\n```shell\n# Navigate to Quartz folder\ncd \u003cpath-to-quartz\u003e\n\n# Commit all changes\ngit add .\ngit commit -m \"message describing changes\"\n\n# Push to GitHub to update site\ngit push origin hugo\n```\n\nNote: we specifically push to the `hugo` branch here. Our GitHub action automatically runs everytime a push to is detected to that branch and then updates the `master` branch for redeployment.\n\n### Setting up the Site\nNow let's get this site up and running. Never hosted a site before? No problem. Have a fancy custom domain you already own or want to subdomain your Quartz? That's easy too.\n\nHere, we take advantage of GitHub's free page hosting to deploy our site. Change `baseURL` in `/config.toml`.\n\nMake sure that your `baseURL` has a trailing `/`!\n\n[Reference `config.toml` here](https://github.com/jackyzha0/quartz/blob/hugo/config.toml)\n\n```toml\nbaseURL = \"https://\u003cYOUR-DOMAIN\u003e/\"\n```\n\nIf you are using this under a subdomain (e.g. `\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz`), include the trailing `/`.\n\n```toml\nbaseURL = \"https://\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz/\"\n```\n\nChange `cname` in `/.github/workflows/deploy.yaml`. Again, if you don't have a custom domain to use, you can use `\u003cYOUR-USERNAME\u003e.github.io`.\n\nPlease note that the `cname` field should *not* have any path `e.g. end with /quartz` or have a trailing `/`.\n\n[Reference `deploy.yaml` here](https://github.com/jackyzha0/quartz/blob/hugo/.github/workflows/deploy.yaml)\n\n```yaml\n- name: Deploy  \n  uses: peaceiris/actions-gh-pages@v3  \n  with:  \n\tgithub_token: ${{ secrets.GITHUB_TOKEN }} # this can stay as is, GitHub fills this in for us!\n\tpublish_dir: ./public  \n\tpublish_branch: master\n\tcname: \u003cYOUR-DOMAIN\u003e\n```\n\nHave a custom domain? [Learn how to set it up with Quartz ](notes/custom%20Domain.md).\n\n---\n\nNow that your Quartz is live, let's figure out how to make Quartz really *yours*!\n\nüé® [Customizing Quartz](notes/config.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-06-29T06:05:34.85107189Z","tags":null},"/sistemas-distribuidos/Examen1/DistribucionesLinux":{"title":"","content":"","lastmodified":"2022-06-29T06:05:34.855071879Z","tags":null}}
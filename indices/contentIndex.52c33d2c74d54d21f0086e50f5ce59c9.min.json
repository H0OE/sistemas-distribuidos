{"/":{"title":"ü™¥ Sistemas Distribuidos","content":"\nResumen de la materia **Sistemas Distribuidos**\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/home.png)\n## √çndice\n- [Distribuciones Linux](Examen1/DistribucionesLinux.md)\n- [Que es](Examen1/Quees.md)\n- [Modelos Fundamentales](Examen1/ModelosFundamentales.md)\n- [TCP-UDP](Examen1/TCP-UDP.md)\n- [Raids](Examen1/Raids.md)\n- [Arquitecturas](Examen1/Aruitecturas.md)\n\n- [Seguridad](Examen2/Seguridad.md)\n- [Teorema CAP](Examen2/CAP.md)\n- [VPN IPsec](Examen2/VPNIPsec.md)\n- [DNS](Examen2/DNS.md)\n- [Exclusi√≥n](Examen2/Exclusion.md)\n- [Hipervisores](Examen2/Hipervisores.md)\n- [LVM](Examen2/LVM.md)\n- [Transacciones](Examen2/Tansacciones.md)\n- [Relojes](Examen2/Relojes.md)\n\n- [Comunicaci√≥n](Examen3/Comunicacion.md)\n- [Replicaci√≥n](Examen3/Replicacion.md)\n\n## Pr√°cticas\n- [SSH](practicas/ssh.md)\n- [Alias](practicas/alias.md)\n- [Discos duros](practicas/discosduros.md)\n- [LVM](practicas/lvm.md)\n- [Apache](practicas/apache.md)\n- [Samba](practicas/samba.md)\n- [Nginx](practicas/nginx.md)\n- [Squid](practicas/squid.md)\n- [DNS](practicas/dns.md)\n","lastmodified":"2022-06-29T20:47:29.110860474Z","tags":null},"/Examen1/Aruitecturas":{"title":"üõ†Ô∏è Arquitexturas","content":"## Modelos Arquitect√≥nicos En Sistemas Distribuidos \nUn modelo arquitect√≥nico puede ser definido como un prototipo o representaci√≥n de la estructura de un sistema, construido con el fin de estudiar distintos aspectos en torno al mismo, como pueden ser el dise√±o o la eficiencia. \n\nLos tipos de modelos arquitect√≥nicos se diferencian en \n- El reparto de responsabilidades entre componentes del sistema\n- La ubicaci√≥n de los componentes del sistema \nTipos de modelos \n- Cliente-servidor \n- Servicios proporcionados por m√∫ltiples servidores proxy y cach√©s\n- Otros derivados\n- Sistemas de igual a igual (peer to peer)\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/peerpeer.webp)\n\n## Arquitectura De Software \nEl t√©rmino arquitectura de software puede ser definido como aquella organizaci√≥n l√≥gica que se enfoca en los componentes de software y como estos interact√∫an con otras estructuras.\n\n### Clasificaci√≥n \nUna vez entendiendo dicho t√©rmino es que se puede hablar de los siguientes modelos: \n#### Modelo Arquitect√≥nico En Capas\nComo su nombre indica, este modelo proporciona un enfoque modular al software, es decir, separa cada componente con el fin de ser m√°s eficiente; de esta manera, se crea un orden en la secuencia de pasos y cuando se realiza una modificaci√≥n a una capa de manera independiente no se afecta al resto del sistema.\n\nPara dejar la idea un poco m√°s clara, un ejemplo que se puede dar de este tipo de arquitectura es el modelo OSI (modelo de interconexi√≥n de sistemas abiertos) el cual utiliza este modelo para obtener mejores resultados. \n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/capas.png)\n#### Modelo Arquitect√≥nico Basado En Objetos\nEl modelo basado en objetos se basa en la idea de tener una cierta disposici√≥n de objetos que se encuentran d√©bilmente acoplados y sin una arquitectura fija. A diferencia del anterior modelo no existe una secuencia de pasos a seguir, en cambio, la interacci√≥n est√° dada a trav√©s de un conector o interfaz donde cada objeto puede interactuar con otro a trav√©s de la llamada de uno o varios m√©todos.\n\nEjemplo de este tipo de modelo arquitect√≥nico son los sistemas de navegaci√≥n y ayuda a la gesti√≥n de transportes, donde distintos componentes (objetos) interact√∫an entre s√≠.\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/objetos.png)\n#### Modelo Arquitect√≥nico Centrado En Datos\nEste modelo de arquitectura funciona bas√°ndose en un repositorio de datos central, tal y como indica su nombre, desde el cual se pueden ingresar y solicitar datos. \n\nUn ejemplo simple de este tipo de modelo es el de un almac√©n de productos, el cual ‚Äúingresa y actualiza‚Äù datos cuando recibe nuevos productos, los cuales pueden ser a su vez solicitados por sus clientes.\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/centdatos.jpg)\n\n#### Modelo Arquitect√≥nico Basado En Eventos\nAl igual que en los casos anteriores, el nombre de esta arquitectura resume de buena manera su funcionamiento, el cual est√° dado a trav√©s de eventos; es decir, cuando ocurre un evento, el sistema suscrito recibe una notificaci√≥n y act√∫a en consecuencia a la misma. \n\nUna de las ventajas y principales diferencias con los anteriores modelos explicados es que los componentes de este modelo est√°n acoplados de manera flexible, lo que facilita el modificarlos, agregarlos o eliminarlos. Ejemplo de este modelo es Facebook, debido a las caracter√≠sticas antes mencionadas.\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/eventarch.png)\n## Arquitectura del sistema\nEste concepto puede ser definido como aquella arquitectura que se basa en el sistema en si y en la ubicaci√≥n de todos los componentes del mismo. Teniendo como punto el de un sistema distribuido, se puede decir que los modelos arquitect√≥nicos que m√°s relevancia tienen en este √°mbito son dos.\n\n### Modelo Arquitect√≥nico Cliente-Servidor (Centralizadas)\nEste modelo, como su nombre indica, consta de un cliente y un servidor. El servidor es donde se encuentran todos los procesos y el cliente es donde el usuario interact√∫a con dicho servidor; en ese sentido, si el cliente solicita algo al servidor, este le responder√°. Este es un modelo que es m√°s estable y seguro que el modelo punto a punto, pero es m√°s lento que el mismo. El ejemplo m√°s grande que se puede dar de un sistema de este tipo es de la World Wide Web, donde se utiliza un programa (navegador) como cliente\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/clientser.webp)\n### Modelo Arquitect√≥nico Punto A Punto (Descentralizadas)\nTambi√©n llamado peer-to-peer o P2P, este modelo funciona teniendo como base la falta de un control central en un sistema distribuido; es decir, un nodo puede actuar como cliente o como servidor en cualquier momento; si el nodo hace una solicitud es tratado como un cliente y si, por el contrario, proporciona algo en respuesta a una solicitud se lo trata como el servidor. Existen tres tipos de Modelos P2P, el modelo estructurado, el no estructurado y el h√≠brido. Ejemplo de esto son los servicios de telefon√≠a por Internet.\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/peertopee.png)\n### H√≠bridas\nMezcla de las 2\n","lastmodified":"2022-06-29T20:47:29.038859951Z","tags":null},"/Examen1/DistribucionesLinux":{"title":"üíª Distribucion de Linux","content":"\nUna distribuci√≥n es un conjunto de programas GNU / Linux debidamente precompilados y configurados para funcionar juntos. Adicionalmente, la mayor√≠a de distribuciones incluyen otros componentes que aportan valor al conjunto. Una distribuci√≥n es una de las formas en que las empresas pueden ganar dinero con software libre. \n\nExisten organizaciones comerciales que se dedican a empaquetar juntos los programas, incluirlos en alg√∫n medio, a√±adir un manual de instrucciones y proporcionar soporte t√©cnico. La mayor√≠a de fabricantes de distribuciones reinvierten una parte de sus beneficios en iniciativas que ayuden a la comunidad de software libre. Tambi√©n existen distribuciones realizadas por voluntarios y que no tienen √°nimo de lucro.\n\n## Caracteristicas\nEntre las cosas que se pueden esperar de una distribuci√≥n moderna se cuentan: \n\t‚Ä¢ Un programa de instalaci√≥n que gu√≠e al usuario desde el principio e instale los paquetes b√°sicos. \n\t‚Ä¢ Un gestor de paquetes que se encargue de proporcionar el interfaz necesario para que el administrador pueda instalar y desinstalar programas de una manera f√°cil. \n\t‚Ä¢ Un entorno gr√°fico (normalmente KDE o GNOME), con el que se integren el resto de los programas. \n\t‚Ä¢ Manuales de instalaci√≥n y uso y documentaci√≥n adicional sobre los programas. \n\t‚Ä¢ Un sistema de seguimiento de errores (bugs) y fallos de seguridad que proporcione al usuario versiones corregidas de los programas lo m√°s r√°pido posible cuando se detecte un fallo.\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/distlinuxcarac.png)\n## Ramas diferentes\n- Basadas en Redhat: Sistema rpm (RedHat, Madrake, SuSE) \n- Basadas en Debian: Sistema de (Debian)\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/debvred.jpg)\n### Redhat\nEs la distribuci√≥n m√°s usada en el mundo; es f√°cil de instalar y de usar. Su gestor de paquetes RPM se ha convertido en un est√°ndar en el mundo GNU/Linux. Incluye multitud de herramientas gr√°ficas.\n\n### Debian\nEs la que mayor cantidad de software contiene. Realizada enteramente por voluntarios y basada exclusivamente en software libre. Su sistema de paquetes dispone de caracter√≠sticas realmente potentes, lo que hace del uno de sus puntos fuertes.\n\n### Distribuiciones\n- stable (Woody): Distribuci√≥n oficial m√°s reciente. Versi√≥n de producci√≥n. Soporte de seguridad. \n- testing (Sarge): Distribuci√≥n de ‚Äúpruebas‚Äù. Versiones de paquetes m√°s recientes a√∫n no aceptadas en la rama estable. \n- unstable (Sid): Distribuci√≥n de desarrollo de Debian.\n\n## Por que Debian\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/porquedeb.jpg)\n### M√∫ltiples arquitecturas y kernels \nActualmente Debian soporta un impresionante n√∫mero de arquitecturas CPU: alpha, amd64, armel, hppa, i386, ia64, mips, mipsel, powerpc, s390, y sparc. Tambi√©n corre con los kernels GNU Hurd y FreeBSD adem√°s de Linux, y con la utilidad debootstrap es dif√≠cil que encuentre un dispositivo que no pueda correr Debian.\n\n### Software de seguridad \nMuchos desconocen que cualquier cosa enviada por la red puede ser le√≠da por cualquier m√°quina entre usted y el receptor. Debian tiene paquetes del famoso software GPG (y PGP) que permite enviar correo entre usuarios preservando su privacidad. Adem√°s, ssh permite crear conexiones seguras a otras m√°quinas que tengan ssh instalado.\n\n### Distribuciones mas usadas\nUna distribuci√≥n derivada de Debian es una distribuci√≥n que est√° basada en el trabajo hecho en Debian pero que tiene sus propias metas, identidad y audiencia, y que ha sido creada por una entidad independiente de Debian. Las distribuciones derivadas modifican Debian para alcanzar sus propias metas. \n\nDebian da la bienvenida y anima a las organizaciones que quieran desarrollar nuevas distribuciones basadas en Debian. Conforme al esp√≠ritu del contrato social de Debian, esperamos que las distribuciones derivadas aporten su trabajo a Debian y a los proyectos originales (¬´upstream¬ª), de forma que todo el mundo se pueda beneficiar de las mejoras que introduzcan.\n\n### Distribuciones destacadas\n‚Ä¢ Grml: sistema ¬´en vivo¬ª (¬´live system¬ª) para administradores del sistema. \n‚Ä¢ Kali Linux: auditor√≠as de seguridad y pruebas de penetraci√≥n. \n‚Ä¢ Purism PureOS: publicaci√≥n contin√∫a enfocada hacia la privacidad, seguridad y comodidad, respaldada por la FSF. \n‚Ä¢ Tails: protecci√≥n de la privacidad y anonimato. \n‚Ä¢ Ubuntu: popularizar Linux en todo el mundo","lastmodified":"2022-06-29T20:47:29.038859951Z","tags":null},"/Examen1/Modelos/ModeloFallos":{"title":"üí¢ Modelo de Fallos","content":"## Tipos de fallo seg√∫n entidad\n- Fallos de proceso\n- Fallos de comunicaci√≥n\n## Tipo de fallo seg√∫n el problema\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/fails.png)\n- Fallos por omisi√≥n **Afecta al canal**\n\t-  No se consigue realizar una acci√≥n que se deber√≠a poder hacer\n\t-  Un mensaje insertado en un b√∫fer de mensajes salientes nunca llega al b√∫fer de mensajes entrantes del destino\n\n- Fallos arbitrarios (bizantinos)¬† **Afecta al proceso o canal**\n\t- Errores de cualquier tipo, fuera del esquema de mensajes\n\t- El proceso/Canal presenta un comportamiento arbitrario: omisiones, paradas, env√≠os o pasos incorrectos sin patr√≥n claro\n\n- Fallos de temporizaci√≥n\n\t- Superaci√≥n de tiempos l√≠mite en un sistema s√≠ncrono\n\n- Fallo del procesamiento (crash)¬† **Afecta al proceso**\n\t- Un mensaje insertado en un b√∫fer de mensajes saliente, otros procesos no pueden detectar la parada\n\n- Fallo parada (fail-stop)¬† **Afecta al proceso**\n\t- Fallo de procesamiento que puede ser detectado con certeza por el resto de los procesos\n\t- El proceso para y permanece parado, otros procesos pueden detectar la parada\n\n- Detecci√≥n del fallo por timeouts (s√≠ncrono)\n\t- Si el proceso no responde consideramos que ha habido un fallo\n\t- En sistemas as√≠ncronos, nunca podemos estar seguros\n\n- Fallo por omisi√≥n en comunicaciones\n\t-  Fallo por omisi√≥n de env√≠o¬† **Afecta al proceso**\n\t\t-  Un proceso completa el envio pero no se coloca el mensaje en el b√∫fer de mensajes salientes\n\t- Fallo por omisi√≥n de comunicaci√≥n¬†**Afecta al canal**\n\t- Fallo por omisi√≥n de recepci√≥n¬† **Afecta al proceso**\n\t\t- El mensaje se coloca en el buffer de recepci√≥n pero el proceso no lo recibe\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/enemy.png)\n\n## Fallos de temporizaci√≥n\n- Sistemas s√≠ncronos\n\t- Reloj Afecta al proceso\n\t\t- El reloj local del proceso excede el l√≠mite de su tasa de deriva respecto al tiempo de referencia\n\t- Prestaciones Afecta el proceso\n\t\t- El proceso excede el l√≠mite sobre el intervalo\n\t- Prestaciones Afecta el canal\n\t\t- La transmisi√≥n de un mensaje toma m√°s tiempo que el tiempo permitido\n- Sistemas As√≠ncronos\n\t- No hay fallos de temporizaci√≥n\n## Comunicaci√≥n fiable entre procesos\nSe debe cumplir la:\n- Validez\n\t- Cualquier mensaje en el b√∫fer de mensajes salientes llegar√° eventualmente al b√∫fer de mensajes entrantes\n\t- Es decir, no hay fallos por omisi√≥n en el canal\n- Integridad\n\t- El mensaje recibido es id√©ntica al enviado y no se repiten mensajes\n\t\t- Protocolo que adjunta n√∫meros de secuencia a los mensajes\n\t\t- Canales de comunicacion seguros\n\t- No hay fallos bizantino\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/memefails.png)","lastmodified":"2022-06-29T20:47:29.038859951Z","tags":null},"/Examen1/Modelos/ModelosInteraccion":{"title":"üî∑ Modelos de interaccion","content":"![Caracteristicas](/sistemas-distribuidos/Examen1/images/modelint1.png)\nRespecto a la interacci√≥n, los sistemas distribuidos deben tener en cuenta que\n- Hay limitaciones debidas a la comunicaci√≥n\n- Es imposible predecir el retraso con el que llega un mensaje\n- Es imposible tener una noci√≥n global de tiempo\n\t- La ejecuci√≥n es no determinista y dif√≠cil de depurar\n\n## Algoritmo distribuido\nDefinici√≥n de los pasos que hay que llevar a cabo por cada uno de los procesos del sistema, incluyendo los mensajes de transmisi√≥n entre ellos.\n\n## Prestaciones del canal de comunicaci√≥n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/com1.png)\n### Latencia\n- Retardo entre el env√≠o de un mensaje y su recepci√≥n\n- Ancho de banda\n- Informaci√≥n que puede transmitirse en un intervalo de tiempo: Fluctuaci√≥n (jitter)\n- Variaci√≥n del tiempo invertido en repartir una serie de mensajes\n\n## Protocolos de Enrutamiento\n- RIP: Es un protocolo de enrutamiento que se basa en el n√∫mero de saltos para decidir cu√°l es la mejor ruta hacia una red de destino.\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/rip.jpg)\n- OSPF: Es un protocolo de enrutamiento cuya m√©trica es el costo. Aquella ruta que posea el menor costo ser√° la ideal y la que ser√° seleccionada como mejor camino hacia una red de destino.\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/ospf.png)\n- BGP: BGP significa Border Gateway Protocol y se utiliza para permitir la comunicaci√≥n entre los routers de borde pertenecientes a sistemas aut√≥nomos diferentes. BGP es un protocolo de gran importancia para las empresas Telco y para los ISPs.\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/bgp.webp)\n- EIGRP: Fue desarrollado por la empresa Cisco Systems y usa una m√©trica compuesta para decidir la mejor ruta hacia una red de destino. Puedes obtener m√°s detalles de su configuraci√≥n y funcionamiento en nuestro Curso gratuito de Fundamentos de EIGRP que encontrar√°s en nuestra plataforma de Telecapp Academy.\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/eigrp.png)\n\n## Relojes y eventos de tiempo\nCada computador tiene su propio reloj interno (reloj local)\n- Puede usarse en procesos locales para marcas de tiempo \n### Tasa de deriva de reloj (clock drift rate)\n- Evoluci√≥n de la diferencia entre un reloj local y un reloj de referencia ‚Äúperfecto‚Äù\n- Receptores GPS\n- Network Time Protocol (NTP)\n- Mecanismos de ordenaci√≥n de eventos\n\n### Dos tipos de modelo de interacci√≥n\n- S√≠ncrono\n- As√≠ncrono\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/syncasyn.png)\nEn la comunicaci√≥n sincr√≥nica, los datos se transfieren en forma de tramas, mientras que, en la asincr√≥nica, los datos se env√≠an de un byte en un byte. La transmisi√≥n sincr√≥nica necesita una se√±al de reloj entre el emisor y el receptor para informar al segundo sobre la llegada del nuevo byte o mensaje.\n\n#### Modelos Sincr√≥nicos\nConocimiento de caracter√≠sticas temporales:\n- El tiempo de ejecuci√≥n de cada etapa de un proceso tiene ciertos l√≠mites inferior y superior conocidos \n- Cada mensaje transmitido sobre un canal se recibe en un tiempo l√≠mite conocido\n\t- Cada proceso tiene un reloj local cuya tasa de deriva sobre el tiempo de referencia tiene un l√≠mite conocido\n- A nivel te√≥rico, podemos establecer unos l√≠mites para tener una idea aproximada de c√≥mo se comportar√° el sistema \n- A nivel pr√°ctico, es imposible garantizar esos l√≠mites siempre \n- Aunque a veces se pueden utilizar, por ejemplo, como tineos\n\n#### Modelos Asincr√≥nicos\nNo hay limitaciones en cuanto a:\n- Velocidad de procesamiento.\n- Retardos en la transmisi√≥n de mensajes.\n- Tasas de deriva de los relojes.\n- Los sistemas distribuidos reales suelen ser as√≠ncronos. \n\tPor ejemplo, Internet.\n- Una soluci√≥n v√°lida para un sistema as√≠ncrono lo es tambi√©n para uno s√≠ncrono.","lastmodified":"2022-06-29T20:47:29.038859951Z","tags":null},"/Examen1/Modelos/ModelosSeguridad":{"title":"üîë Modelos de Seguridad","content":"La seguridad en un sistema distribuido se basa en la seguridad de los procesos y canales utilizados\n- Entendida como seguridad de objetos\n- Almacenados e invocados por los procesos\n- Transmitidos a trav√©s de los canales\n- Se logra mediante un sistema de derechos de acceso y distintos tipos de autoridad\n\n## Principal\nAutoridad con la que se ordena cada invocaci√≥n de objetos o sus resultados\n- Se contrasta con los derechos de acceso de dicho objeto\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/segu1.jpg)\n## Modelo de enemigo\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/enemy2.jpg)\n### Entidad\nCualquier m√°quina conectada( de forma autorizada o no) a la red \n### Enemigo \nEntidad capaz de:\n- Enviar cualquier mensaje a cualquier proceso\n- Leer o copiar cualquier mensaje compartido entre dos procesos\n- Leer mensajes o emitir mensajes falsos de petici√≥n de servicios.\n\n## Amenazas a servidores\nCiertos servicios no comprueban la identidad del cliente\n- Si la comprueban, no suele ser dif√≠cil suplantarla (spoofing)\n\nEn vez de una petici√≥n de servicio aut√©ntica se busca, p. ej., obtener informaci√≥n no autorizada o bloquear el servicio (DoS)\n\n## Amenazas a clientes\n- Reciben un resultado falso de la invocaci√≥n al servicio\n- Generalmente, acompa√±ado de suplantaci√≥n de identidad\n\n## Amenazas a canales de comunicaci√≥n\n- Inyecci√≥n, copia o alteraci√≥n de mensajes que viajan por el canal\n\nPor ejemplo: obtener un mensaje de transferencia de dinero, cambiar la cuenta y re enviarlo despu√©s\n\n## T√©cnicas de seguridad\n- Autenticaci√≥n: Comprobaci√≥n de la identidad del proceso\n- Criptograf√≠a: Uso de claves p√∫blicas y privadas\n- Canales seguros: Canal de comunicaci√≥n sobre el que dos procesos han establecido una capa de seguridad basada en criptograf√≠a + autenticaci√≥n:\n\t- Se garantiza la identidad fiable de servidores y clientes\n\t- Se garantiza la integridad y privacidad de los mensajes enviados\n\t- Los mensajes incluyen una marca de tiempo para prevenir su repetici√≥n o reordenaci√≥n maliciosa\n","lastmodified":"2022-06-29T20:47:29.038859951Z","tags":null},"/Examen1/ModelosFundamentales":{"title":"ü¶º Modelos Fundamentales","content":"![Caracteristicas](/sistemas-distribuidos/Examen1/images/models.jpg)\nTodas las arquitecturas comparten algunas propiedades fundamentales: \nProcesos que se comunican por paso de mensajes a trav√©s de una red de computadores. \n- [Modelos de interacci√≥n](Examen1/Modelos/ModelosInteraccion.md): El modelo debe definir y clasificar la comunicaci√≥n entre elementos del sistema.\n- [Modelo de Fallos](Examen1/Modelos/ModeloFallos.md): El modelo debe definir y clasificar los fallos que pueden darse en el sistema. \n- [Modelos de Seguridad](Examen1/Modelos/ModelosSeguridad.md): El modelo debe definir y clasificar los tipos de ataque que pueden afectar al sistema.\n\n\n\n","lastmodified":"2022-06-29T20:47:29.038859951Z","tags":null},"/Examen1/Quees":{"title":"üñ•Ô∏è Sistemas Distribuidos","content":"![Caracteristicas](/sistemas-distribuidos/Examen1/images/sistdist.png)\n## Que es\n**Conjunto de equipos independientes que act√∫an de forma transparente como un √∫nico equipo.**\n\nSu funci√≥n es la descentralizaci√≥n del almacenamiento de la informaci√≥n o c√≥mputo (BD-SERVIDORES). Tambi√©n puede definirse como una colecci√≥n de computadoras independientes, separadas f√≠sicamente, pero que aparentan ser un solo equipo realizando las m√∫ltiples tareas\n\n‚Ä¢ Se implementan en diversas plataformas de hardware y software. \n‚Ä¢ Todo se conecta por red.\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/ventajasydesve.jpg)\n## Ventajas\n‚Ä¢ Eficacia. Uso racional de los recursos con que se cuenta para alcanzar un objetivo predeterminado. A mayor eficiencia menor la cantidad de recursos que se emplear√°n, logrando mejor optimizaci√≥n y rendimiento. \n‚Ä¢ Tolerancia a fallos. Permite que, en caso de que una computadora falle, otra la pueda sustituir en la realizaci√≥n de sus tareas asignadas. Al estar distribuida la informaci√≥n en nodos, en caso de que se caiga un nodo, dicha informaci√≥n va a encontrarse replicada en otros nodos. \n‚Ä¢ Mayor velocidad. Est√° en referencia a los tiempos de respuesta de una aplicaci√≥n; cuando se realiza una consulta, los procesamientos se dividen entre todos los nodos que forman el sistema distribuido, en lugar de enviarlos a un √∫nico nodo y que el mismo tenga que hacer todo el trabajo. \n‚Ä¢ Procesamiento distribuido. Se puede definir como la forma en que es posible conectar distintas m√°quinas, logrando as√≠, que una sola tarea de procesamiento de datos pueda ser procesada o ejecutada entre varias m√°quinas de la red, es decir, que un solo proceso se pueda actuar entre varias m√°quinas diferentes y conectadas a una red. \n‚Ä¢ Escalabilidad. Permite que a la arquitectura actual se le pueda adicionar m√°s poder de c√≥mputo. Se entiende por escalabilidad a la capacidad de adaptaci√≥n y respuesta de un sistema con respecto al rendimiento del mismo a medida que aumentan de modo significativo el n√∫mero de usuarios del mismo.\n\n## Desaf√≠os\n1. Seguridad. - Mantener la confidencialidad, integridad y disponibilidad de los recursos en la red. \n2. Concurrencia. - El sistema debe permitir m√∫ltiples usuarios utilizando simult√°neamente los recursos de la red. \n3. Extensibilidad. - Poder soportar nuevas funcionalidades o cambios en el sistema. \n4. Resiliencia (Tratamiento a fallos). - Un Sistema Distribuido debe poder detectar, ocultar y recuperarse de fallos que puedan ocurrir en la red. \n5. Escalabilidad. - El sistema debe mantener el rendimiento de los recursos cuando se aumenta el n√∫mero de usuarios (consumidores). \n6. Transparencia. - Para el usuario y/o el programador de aplicaciones, el sistema debe ser percibido como un todo m√°s que como una colecci√≥n de recursos. \n7. Heterogeneidad. - Consiste en la capacidad de poder a√±adir o reemplazar los componentes de la red (lenguajes de programaci√≥n, sistemas operativos, protocolos, formatos, redes, hardware).","lastmodified":"2022-06-29T20:47:29.038859951Z","tags":null},"/Examen1/Raids":{"title":"üñ•ü§Ø RAID","content":"## HDD vs SSD\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/hhdssd.jpg)\n### HDD\nLos discos duros, tambi√©n conocidos como HDD, son un componente inform√°tico que sirve para almacenar de forma permanente tus datos. Esto quiere decir, que los datos no se borran cuando se apaga la unidad como pasa en los almacenados por la memoria RAM. La primera empresa en comercializarlos fue IBM en 1956. \n\nEst√°n compuestos de piezas mec√°nicas, de ah√≠ que a veces se le llame discos duros mec√°nicos, y utilizan el magnetismo para grabar tus datos y archivos. Se compone de uno o varios discos r√≠gidos unidos por un mismo eje y que giran a gran velocidad dentro de una caja met√°lica. En cada plato y en cada una de sus caras, un cabezal de lectura/escritura lee o graba tus datos sobre los discos\n\n### SSD\nLas unidades de estado s√≥lido o SSD (Solid State Drive) son una alternativa a los discos duros. La gran diferencia es que mientras los discos duros utilizan componentes mec√°nicos que se mueven, las SSD almacenan los archivos en microchips con memorias flash interconectadas entre s√≠. Por lo tanto, casi podr√≠amos considerarlos como una evoluci√≥n de las memorias USB. \n\nLos SSD suelen utilizar memorias flash basadas en NAND, que como tambi√©n son no-vol√°tiles mantienen la informaci√≥n almacenada cuando el disco se desconecta. No tienen cabezales f√≠sicos para grabar los datos, en su lugar incluyen un procesador integrado para realizar operaciones relacionadas con la lectura y escritura de datos.\n\n\n## Raid\nRAID es la sigla para \" Redundant Array of Independent Disks \". Su definici√≥n en espa√±ol ser√≠a \"Matriz Redundante de Discos Independientes \". Se trata de una tecnolog√≠a que combina varios discos r√≠gidos (HD) para formar una √∫nica unidad l√≥gica, donde los mismos datos son almacenados en todos los discos (redundancia). \n\nLa tecnolog√≠a RAID protege los datos contra el fallo de una unidad de disco duro. Si se produce un fallo, RAID mantiene el servidor activo y en funcionamiento hasta que se sustituya la unidad defectuosa. \n\nLa tecnolog√≠a RAID se utiliza tambi√©n con mucha frecuencia para mejorar el rendimiento de servidores y estaciones de trabajo. Estos dos objetivos, protecci√≥n de datos y mejora del rendimiento, no se excluyen entre s√≠.\n\n### Raid 0\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/raid0.jpg)\nNo ofrece tolerancia a fallos, pero si mayor velocidad, algunos no consideran a esta configuraci√≥n como un RAID verdadero. Una configuraci√≥n RAID 0 con dos discos es hasta dos veces m√°s r√°pidas que un solo disco duro. **Se utiliza en entornos de laboratorio para medir las entradas y salidas de un sistema por su rapidez.**\n\n### Raid 1\nTambi√©n conocido como \"Mirroring \" o \" Espejado \", el RAID 1 funciona a√±adiendo discos r√≠gidos paralelos a los discos r√≠gidos principales existentes en la computadora. De esta manera, si, por ejemplo, una computadora posee 2 discos, se puede anexar un disco r√≠gido para cada uno, totalizando 4. **Los discos que fueron a√±adidos, trabajan como una copia del primero. **\n\nLa consecuencia en este caso, es que la grabaci√≥n de datos es m√°s lenta, pues es realizada dos veces. Sin embargo, la lectura de esa informaci√≥n es m√°s r√°pida, pues puede ser accedida de dos fuentes. **Se utiliza para el Sistema Operativo, debido a que es una copia tal cual, en caso de un fallo del mismo, es m√°s lento.**\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/raid1.png)\n\n### Raid 5\nEste RAID ofrece tolerancia al fallo, pero adem√°s optimiza la capacidad del sistema permitiendo una utilizaci√≥n de hasta el 80% de la capacidad del conjunto de discos. Esto lo consigue mediante el c√°lculo de la informaci√≥n de paridad y su almacenamiento alternativo por bloques en todos lo discos del conjunto. La informaci√≥n del usuario se graba por bloques y de forma alternativa en todos ellos. Uso m√≠nimo de 3 discos. En resumen, el RAID 5 es un buen sistema integral que combina almacenamiento eficiente con excelente seguridad y rendimiento. **Es ideal para servidores de archivos y aplicaciones que tienen un n√∫mero limitado de unidades de datos.**\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/raid5.png)\n\n### Raid 6\n**Acceso independiente con doble paridad**\nSimilar al RAID 5, pero incluye un segundo esquema de paridad distribuido por los distintos discos y por tanto ofrece tolerancia extremadamente alta a los fallos y a las ca√≠das de disco, ofreciendo dos niveles de redundancia. \n\nSi fallan m√°s de dos unidades de disco, los datos se tienen que restaurar a partir del medio de copia de seguridad. L√≥gicamente, la capacidad de dos unidades de disco est√° dedicada a almacenar datos de paridad en un conjunto de paridad. No obstante, en la pr√°ctica, los datos de paridad se reparten entre varias unidades de disco. \n\nEl n√∫mero m√≠nimo de unidades de disco en un conjunto de paridad es de 4. El n√∫mero m√°ximo de unidades de disco en un conjunto de paridad es de 18. RAID 6 permite almacenar grandes cantidades de datos a prueba de fallos a largo plazo al amortiguar dos posibles fallos. **Por tanto, los sistemas de servidores en los que se archivan datos son un caso de aplicaci√≥n ideal.**\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/raid6.png)","lastmodified":"2022-06-29T20:47:29.038859951Z","tags":null},"/Examen1/TCP-UDP":{"title":"üìΩÔ∏è TCP-UDP","content":"\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/tcpudp.jpg)\n## TCP\nTCP (Protocolo de Control de Transmisi√≥n, por sus siglas en ingl√©s Transmission Control Protocol) es protocolo de red importante que permite que dos anfitriones (hosts) se conecten e intercambien flujos de datos. TCP garantiza la entrega de datos y paquetes (en-US) en el mismo orden en que se enviaron.\n\n## UDP\nEl Protocolo de datagrama de usuario (UDP) es un protocolo ligero de transporte de datos que funciona sobre IP. UDP proporciona un mecanismo para detectar datos corruptos en paquetes, pero no intenta resolver otros problemas que surgen con paquetes, como cuando se pierden o llegan fuera de orden.\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/tcpudp2.png)\n## Diferencias\n- Conexi√≥n: TCP es un protocolo orientado a la conexi√≥n mientras que UDP no utiliza conexi√≥n. TCP establece una conexi√≥n entre un remitente y un receptor antes de que se puedan enviar los datos. UDP en cambio, no establece ninguna conexi√≥n antes de enviar los datos. \n- Fiabilidad: TCP es confiable ya que garantiza que los datos enviados mediante el protocolo TCP se entreguen al receptor. Si los datos se pierden en el camino, los recuperar√° y los reenviar√°. TCP tambi√©n verifica los paquetes en busca de errores y los rastrea para que los datos no se pierdan ni se corrompan. En cambio, UDP no es confiable. Este no garantiza la entrega de los paquetes y los paquetes pueden corromperse o perderse en tr√°nsito. \n- Control de Flujo: TCP utiliza un mecanismo de control de flujo que garantiza que el remitente no sature al receptor enviando demasiados paquetes a la vez. Este, almacena los datos en un b√∫fer de env√≠o y los recibe en un b√∫fer de recepci√≥n. Cuando la aplicaci√≥n est√° lista, lee los datos del b√∫fer de recepci√≥n. Si el b√∫fer de recepci√≥n est√° lleno, el receptor no puede manejar m√°s datos y los elimina. Cada vez que el receptor recibe un paquete, env√≠a un mensaje al remitente. UDP, no proporciona control de flujo. Con UDP, los paquetes llegan de forma continua o se descartan. \n- Ordenaci√≥n: TCP ordena los paquetes para garantizar que se entreguen al cliente en el mismo orden en que se enviaron. En cambio, UDP env√≠a los paquetes sin importar el orden. \n- Velocidad: Otra diferencia entre TCP y UDP, es que TCP es m√°s lento, porque hace mucho m√°s que enviar datos. TCP establece una conexi√≥n, verifica los errores y garantiza que los archivos se reciban en el orden en que fueron enviados tal y como hemos comentado anteriormente. Por lo tanto, la velocidad es uno de los aspectos en los que destaca UDP. \n\n- Uso: TCP es el protocolo m√°s adecuado para usarse en aplicaciones que requieren una alta confiabilidad.\n\t- P√°ginas web (HTTP, HTTPS) \n\t- Correo electr√≥nico (SMTP, IMAP/POP) \n\t- SSH \n\t- FTP\n- UDP es m√°s adecuado para aplicaciones que requieren velocidad y eficiencia.\n\t- VPN \n\t- Juegos online \n\t- Videos en directo\n\t- DNS \n\t- Voz a trav√©s de internet (VoIP) \n\t- TFTP\n\n![Caracteristicas](/sistemas-distribuidos/Examen1/images/tcpudp3.png)","lastmodified":"2022-06-29T20:47:29.038859951Z","tags":null},"/Examen2/CAP":{"title":"ü™¥ Teorema CAP","content":"![Caracteristicas](/sistemas-distribuidos/Examen2/images/cap.png)\nEl Teorema CAP indica que los sistema distribuido de almacenamiento de datos pueden llegar a ser vulnerables a fallos por conectividad en la red, es por esto que indica que estos sistemas solo pueden llegar a tener dos de los tres siguientes atributos:\n-   Consistencia: Este atributo quiere decir que sin importar el lugar o la instancia del servicio que se est√© usando, este siempre tiene que ser el mismo, por ejemplo las bases de datos SQL quieren lograr esto por lo que existe diferentes m√©todos y restricciones para lograrlo, en MYSQL existen las transacciones que garantiza esto y tambi√©n el comando LOCK TABLE para evitar que otro usuario lea esta base de datos mientras otro la escribe, con el fin de evitar lecturas sucias.\n-   Disponibilidad: Esto quiere decir que la respuesta ser√° v√°lida y se deber√° dar en un tiempo razonable, es decir que no tarde m√°s de lo debido. Esto es importante si lo que se quiere es obtener los datos de manera r√°pida y garantizar que se obtendr√°n como es el caso de las bases de datos SQL.\n-   Tolerancia a particiones: Esto quiere decir que el sistema debe permanecer estable aun cuando algunos nodos no se encuentren disponibles, ya que se supone que el resto de los nodos tienen la informaci√≥n de manera consistente.\n    \n\nAhora como se mencion√≥ anteriormente este teorema dice que solo se puede garantizar dos de estos tres atributos creando combinaciones entre ellos, por ejemplo tener Consistencia y disponibilidad como es el caso de las bases de datos SQL, tener disponibilidad y tolerancia a particiones o tener consistencia y tolerancia a particiones.\n\nEjemplos:\n\n- CA : MySQL, Postgres, Aster Data, Greenpium, Vertica.\n\n- AP: SimpleDB, CouchDB, Cassandra, Riak, Dynamo, [Voldemort](https://www.project-voldemort.com/voldemort/)\n\n- CP: MongoDB, Terrastore, Scalaris, Berkeley DB, MemcacheDB.\n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/cap2.png)","lastmodified":"2022-06-29T20:47:29.094860358Z","tags":null},"/Examen2/DNS":{"title":"ü™¥ DNS","content":"![Caracteristicas](/sistemas-distribuidos/Examen2/images/dns.png)\n Una base de datos jer√°rquica y distribuida que almacena nombres de dominios y su relaci√≥n a otra informaci√≥n como IP‚Äôs\n    \n## Jerarqu√≠a\n- Root\n-  Nivel Superior (net,com,org)\n- Segundo Nivel (nombre)\n- Subdominio\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/dnsjer.png)\n\n## Fully Qualified Domain Name FQDN \nEs la ruta completa de una p√°gina o recurso en internet con respecto a toda la jerarqu√≠a.\n- Consulta Recursiva: Se tiene la informaci√≥n del recurso en el servidor y el mismo logra proveer una respuesta\n- Consulta Iterativa: El servidor tiene que buscar el recurso externamente y una vez que lo encuentra lo guarda en su cache y devuelva la respuesta (outsourcing)\n- Reenviadores: b√°sicamente un servidor mucho m√°s r√°pido y con m√°s memoria para resolver requests mucho m√°s eficientemente¬†\n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/fqdn.jpg)\n\n## Registro de recursos:\n - A: Resuelve un nombre de host a una IP\n - Ptr: Resuelve IP a un host name\n - Mx: Servidor de correo\n - Ns: identifica el servidor de dns para cada zona\n ![Caracteristicas](/sistemas-distribuidos/Examen2/images/dns%20regi.png)","lastmodified":"2022-06-29T20:47:29.094860358Z","tags":null},"/Examen2/Exclusion":{"title":"ü™¥ Secci√≥n cr√≠tica","content":"Existen m√∫ltiples caracter√≠sticas que un sistema distribuido debe de cumplir, como:\n- confiabilidad\n- disponibilidad\n- apertura\n- integridad de informaci√≥n\n\nDentro de la integridad de informaci√≥n, un problema relevante son las condiciones de competencia que se generan al tener recursos compartidos. Por esta raz√≥n, el tema de la **exclusi√≥n mutua** se vuelve de sumo inter√©s. \n\nEste problema debe de ser resuelto para asegurar el acceso de forma correcta a los recursos compartidos, con la finalidad de mantener la integridad y consistencia en los datos.\n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/seccion.webp)\n\n## Deadlock\nCada proceso debe de pedir permiso para poder entrar en la regi√≥n cr√≠tica y debe de liberarla despu√©s de haberla ocupado en su ejecuci√≥n, para permitir, a otro proceso, entrar a la regi√≥n cr√≠tica. Un algoritmo de exclusi√≥n mutua se define como el mecanismo\n\nPara poder asegurar que solo un proceso est√© en la regi√≥n cr√≠tica, debe de asegurar que no existan deadlocks.\n\nUn Deadlock (tambi√©n llamado \"bloqueo mutuo\", \"abrazo mortal\", ‚Äúpunto muerto\", etc.) sucede cuando dos o m√°s transacciones intentan hacer bloqueos de claves en orden opuesto, por ejemplo:\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/deadlock.png)\n\n## Secci√≥n cr√≠tica (secci√≥n cr√≠tica y regi√≥n cr√≠tica son denominaciones equivalentes) \nEn programaci√≥n concurrente de ciencias de la computaci√≥n, a la porci√≥n de c√≥digo de un programa de ordenador en la que se accede a un recurso compartido (estructura de datos o dispositivo) que no debe ser accedido por m√°s de un proceso o hilo en ejecuci√≥n. \n\nLa secci√≥n cr√≠tica por lo general termina en un tiempo determinado y el hilo, proceso o tarea √∫nicamente tendr√° que esperar un per√≠odo determinado de tiempo para entrar. Se necesita un mecanismo de sincronizaci√≥n en la entrada y salida de la secci√≥n cr√≠tica para asegurar la utilizaci√≥n en exclusiva del recurso, por ejemplo un sem√°foro, monitores, el algoritmo de Dekker y Peterson, los candados.\n\n## Requisitos \nSe denomina regi√≥n cr√≠tica, (secci√≥n cr√≠tica y regi√≥n cr√≠tica son denominaciones equivalentes) en programaci√≥n concurrente de ciencias de la computaci√≥n, a la porci√≥n de c√≥digo de un programa de ordenador en la que se accede a un recurso compartido (estructura de datos o dispositivo) que no debe ser accedido por m√°s de un proceso o hilo en ejecuci√≥n.\n\nProceso entra a ejecutar una secci√≥n cr√≠tica en al que accede a unas variables compartidas, entonces otro proceso no puede entrar a ejecutar una secci√≥n cr√≠tica\nLas secciones cr√≠ticas se pueden agrupar en clases, siendo mutuamente exclusivas.\n\nSe debe implementar protocolos de software que impidan o bloqueen en acceso a una secci√≥n cr√≠tica.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/secc3.png)\n## Exclusi√≥n mutua distribuida\nDicho problema es conocido como el problema de la secci√≥n cr√≠tica en el dominio de los SO. En los sistemas distribuidos se requiere una soluci√≥n que est√© basada exclusivamente en el paso de mensajes.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/exclusion.png)\n### Requisitos\nLos requisitos esenciales para la exclusi√≥n mutua son:\n- EM1 (seguridad): a lo sumo un proceso puede estar ejecut√°ndose una vez en la secci√≥n cr√≠tica.\n- EM2 (superveniencia): las peticiones para entrar y salir de la secci√≥n cr√≠tica al final deben ser concedidas. Esto implica la inexistencia de deadlocks e inanici√≥n.\n- EM3 (ordenaci√≥n): si una petici√≥n parar entrar en la SC ocurri√≥ antes que otra, entonces la entrada en la SC se garantiza en ese orden.\n\n### Mecanismos para garantizar la exclusi√≥n mutua\n##### Sem√°foros\nM√©todo cl√°sico para restringir o permitir el acceso a recursos compartidos (por ejemplo, un recurso de almacenamiento del sistema o variables del c√≥digo fuente) en un entorno de multiprocesamiento\n\nUn tipo simple de sem√°foro es el binario, que puede tomar solamente los valores 0 y 1. Se inicializan en 1 y son usados cuando solo un proceso puede acceder a un recurso a la vez\n\nControla los procesos dentro de memoria en el √°rea de datos compartidos (lectura, lectura/escritura, escritura).\n\nTrabaja con dos elementos:\n- se√±al (despertar)\n- espera (dormir)\n\nDependiendo del tipo de operaci√≥n en el √°rea de datos compartidos, ser√° el sem√°foro que se implante.\n\nEl uso de sem√°foros depende del n√∫mero de procesos; en √°reas de datos no compartidos no tiene raz√≥n de ser.\n\nCuando cualquier proceso accede a los recursos compartidos, realiza la operaci√≥n wait() en el sem√°foro y cuando el proceso libera los recursos compartidos, realiza la operaci√≥n signal() en el sem√°foro. El sem√°foro no tiene variables de condici√≥n. \n\nCuando un proceso est√° modificando el valor del sem√°foro, ning√∫n otro proceso puede modificar simult√°neamente el valor del sem√°foro.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/sem.jpg)\n\n#### Monitores\nun monitor es un programa que observa y administra los procesos dentro del CPU.\n\nSe pueden implementar monitores en memoria en √°reas de datos compartidos y no compartidos.\n\nUn monitor contiene el c√≥digo relativo a un recurso compartido en un solo m√≥dulo de programa\n\nLa interfaz del monitor es un conjunto de funciones que representan las diferentes operaciones que pueden hacerse con el recurso.\n\nUna construcci√≥n de sincronizaci√≥n de alto nivel de tipo Monitor. Es un tipo de datos abstracto. El tipo Monitor contiene variables compartidas y el conjunto de procedimientos que operan en la variable compartida.\n\nCuando cualquier proceso desea acceder a las variables compartidas en el monitor, necesita acceder a ellas a trav√©s de los procedimientos. Estos procesos se alinean en una cola y solo se les proporciona acceso cuando el proceso anterior libera las variables compartidas. √önicamente un proceso puede estar activo en un monitor a la vez. El monitor tiene variables de condici√≥n.\n\n##### Ventajas:\n‚Ä¢ Mantenimiento m√°s simple\n‚Ä¢ Menos errores de programaci√≥n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/mon.jpg)\n\n### Monitores vs Semaforos\n#### Ventajas monitores\n- Los monitores son f√°ciles de implementar que los sem√°foros.\n- La exclusi√≥n mutua en los monitores es autom√°tica, mientras que en los sem√°foros, la exclusi√≥n mutua debe implementarse expl√≠citamente.\n- Los monitores pueden superar los errores de sincronizaci√≥n que se producen al utilizar sem√°foros.\n- Las variables compartidas son globales para todos los procesos en el monitor, mientras que las variables compartidas est√°n ocultas en sem√°foros.\n\n#### Ventajas semaforos\n- Los sem√°foros son independientes de la m√°quina (porque est√°n implementados en los servicios del kernel).\n- Los sem√°foros permiten que m√°s de un hilo acceda a la secci√≥n cr√≠tica, a diferencia de los monitores.\n- En los sem√°foros no hay desperdicio de recursos debido a que no hay esperas ocupadas.\n\n### Algoritmo de Dekker\nEs un algoritmo de programaci√≥n concurrente para exclusi√≥n mutua, que permite a dos procesos o hilos de ejecuci√≥n compartir un recurso sin conflictos si ambos procesos intentan acceder a la secci√≥n cr√≠tica simult√°neamente, el algoritmo elige un proceso seg√∫n una variable turno. Si el otro proceso est√° ejecutando en su secci√≥n cr√≠tica, deber√° esperar su finalizaci√≥n.\n\nExisten cinco versiones del algoritmo Dekker, teniendo ciertos fallos los primeros cuatro. **La versi√≥n 5 es la que trabaja m√°s eficientemente, siendo una combinaci√≥n de la 1 y la 4.**\n\n1. Versi√≥n 1: Alternancia estricta. Garantiza la exclusi√≥n mutua, pero su desventaja es que acopla los procesos fuertemente, esto significa que los procesos lentos atrasan a los procesos r√°pidos.\n2. Versi√≥n 2: Problema interbloqueo. No existe la alternancia, aunque ambos procesos caen a un mismo estado y nunca salen de ah√≠.\n3. Versi√≥n 3: Colisi√≥n regi√≥n cr√≠tica no garantiza la exclusi√≥n mutua. Este algoritmo no evita que dos procesos puedan acceder al mismo tiempo a la regi√≥n cr√≠tica.\n4. Versi√≥n 4: Postergaci√≥n indefinida. Aunque los procesos no est√°n en interbloqueo, un proceso o varios se quedan esperando a que suceda un evento que tal vez nunca suceda.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/dekker.png)\n### Algoritmo Petterson\nAlgoritmo de programaci√≥n concurrente para exclusi√≥n mutua, que permite a dos o m√°s procesos o hilos de ejecuci√≥n compartir un recurso sin conflictos, utilizando solo memoria compartida para la comunicaci√≥n \nCada proceso tiene un turno para entrar en la secci√≥n cr√≠tica, di desea entrar debe activar su se√±al y puede que tenga que esperar a que llegue su turno\n- Version simplificada del algoritmo de Dekker\n- El protocolo de entrada es m√°s elegante con las mismas garant√≠as de exclusi√≥n mutua, imposibilidad de bloqueo mutuo y de aplazamiento indefinido.\n- El algoritmo de Decker resuelve el problema de la exclusi√≥n mutua pero mediante un programa complejo, dif√≠cil de seguir y cuya correcci√≥n es dif√≠cil de demostrar. Peterson ha desarrollado una soluci√≥n simple y elegante. Como antes, la variable global se√±al indica la posici√≥n de cada proceso con respecto a la exclusi√≥n mutua y la variable global turno resuelve los conflictos de simultaneidad.\n\n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/pet.png)\n","lastmodified":"2022-06-29T20:47:29.094860358Z","tags":null},"/Examen2/Hipervisores":{"title":"ü™¥ Hipervisores","content":"![Caracteristicas](/sistemas-distribuidos/Examen2/images/hip.jpg)\nSoftware que permite la virtualizaci√≥n\n\n-   Tipo 1: se instala directamente y corre en el hardware\n    \n-   Tipo 2: corre a partir de un sistema operativo\n## Tipo 1\nUn hipervisor simple (Tipo 1) es una capa de software que instalamos directamente sobre un servidor f√≠sico y su hardware subyacente.\n\nNo hay software ni ning√∫n sistema operativo en el medio, de ah√≠ el nombre de ¬´hipervisor simple¬ª. Por esta raz√≥n, los hipervisores de tipo 1 demostraron proporcionar un rendimiento y una estabilidad excelentes, ya que no se ejecutan dentro de Windows u otros sistemas operativos.\n\nLos hipervisores tipo 1 son un sistema operativo en s√≠ mismo, uno muy b√°sico sobre el que se ejecutan m√°quinas virtuales. Esto significa que la m√°quina f√≠sica en la que se ejecuta el hipervisor sirve solo para prop√≥sitos de virtualizaci√≥n. No podr√°s utilizarlo para nada m√°s.\nPor lo tanto, encontramos principalmente hipervisores de tipo 1 en entornos empresariales.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/hip1.png)\n\n## Tipo 2\nEste tipo de hipervisor se ejecuta dentro de un sistema operativo de una m√°quina host f√≠sica.\n\nEs por esto que llamamos hipervisores alojados de hipervisores de tipo 2. A diferencia de los hipervisores de tipo 1 que se ejecutan directamente en el hardware, los hipervisores alojados tienen una capa de software debajo. Lo que tenemos en este caso es:\n- Una m√°quina f√≠sica.\n- Un sistema operativo instalado en el hardware (Windows, Linux, MacOS).\n- Un software de hipervisor de tipo 2 dentro de ese sistema operativo.\n- Las instancias reales de m√°quinas virtuales invitadas.\n- Los hipervisores de tipo 2 generalmente se encuentran en entornos con una peque√±a cantidad de servidores.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/hip2.png)\n","lastmodified":"2022-06-29T20:47:29.094860358Z","tags":null},"/Examen2/LVM":{"title":"ü™¥ LVM","content":"\nSistema de administraci√≥n de una colecci√≥n de unidades de almacenamiento, divididas l√≥gicamente para su f√°cil uso y extensi√≥n.\n    \n-   Permite realizar operaciones en caliente (mover discos, expandir, tomar snapshots) sin tener que parar el sistema.\n    \n-   Puede ser m√°s complicada de setup y se puede perder toda la informaci√≥n si una unidad falla\n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/lvm.png)\n## Physical Volume PV \nEs cualquier dispositivo f√≠sico que pueda almacenar datos. De estos dispositivos parte el LVM\n    \n## Volume Group \nEs un grupo de PV‚Äôs\n\n## Logical Volume \nLa divisi√≥n l√≥gica de todo el VG. (Si se tiene 2 discos de 1 Gb cada uno en un VG, podemos asignar el uso de 1.5Gb en total de todo el VG)\n\n## Cuando usar\nLa primera cosa que debe considerar antes de la creaci√≥n de LVM es lo que se quiere lograr con sus discos y particiones. Algunas distribuciones, como Fedora, se instala LVM por defecto.\nSi usted est√° utilizando otra distribuci√≥n en una port√°til con un solo disco duro interno y no necesita las caracter√≠sticas extendidas como snapshots en vivo, entonces puede que no necesite LVM. Si usted necesita una f√°cil expansi√≥n o desea combinar varios discos duros en un √∫nicamente grupo de almacenamiento, LVM puede ser lo que usted ha estado buscando.\n\n## Desventajas\nLa configuraci√≥n inicial de LVM es m√°s compleja que simplemente particiones un disco, y definitivamente necesitar√° comprender la terminolog√≠a y el modelo de LVM (vol√∫menes l√≥gicos, vol√∫menes f√≠sicos, grupos de vol√∫menes) antes de poder comience us√°ndolo. (Sin embargo, una vez que est√° configurado, emplearlo es mucho m√°s f√°cil).\n\nAdem√°s, si usa LVM en discos duros, puede perder todos sus datos cuando falla una sola unidad.\n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/lvm2.jpg)","lastmodified":"2022-06-29T20:47:29.094860358Z","tags":null},"/Examen2/Relojes":{"title":"‚åö Relojes","content":"![Caracteristicas](/sistemas-distribuidos/Examen2/images/rel.jpg)\nExisten 2 tipos de relojes:\n- Relojes F√≠sicos\nAquellos que est√°n directamente relacionados con el tiempo real y la concepci√≥n que tenemos de este.\n\n- Relojes L√≥gico\nAquellos que tienen como importancia el orden de los eventos.\n\nLas computadoras tienen por lo general un reloj f√≠sico de cuarzo que basa su medici√≥n de tiempo en las oscilaciones del cristal. \n\nLas oscilaciones de los cristales pueden ser de diferentes velocidades lo que generar√≠a un sesgo de reloj, lo que quiere decir que los relojes de 2 dispositivos se encuentran desincronizados. \n\nPara evitar que los relojes dentro de un sistema se encuentren desincronizados, es necesario implementar algoritmos o protocolos de sincronizaci√≥n. \n\n## Distorsion de reloj\nLa diferencia entre los valores del tiempo se llama **distorsi√≥n del reloj**.\n\nComo consecuencia de esta distorsi√≥n, podr√≠an fallar los programas que esperan que \nel tiempo asociado a un archivo, objeto, proceso o mcnsaje sea correcto e independiente del sitio donde haya sido generado (es decir, del reloj utilizado).\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/dist.png)\n## Categoria de algoritmos\nDentro de los algoritmos podemos definir 4 categor√≠as:\n- Internos: La sincronizaci√≥n sucede dentro de la red.\n- Externos: Se hace la petici√≥n de la hora a un servidor externo confiable.\n- Pasivos: Los nodos piden la hora.\n- Activos: El servidor o el maestro de la hora pregunta por las horas de los dem√°s y env√≠a instrucciones.\n\n## Algoritmos\n### Algoritmo de Christian\nEste algoritmo propone tener un servidor externo UTC al que los nodos del sistema preguntar√°n la hora para poder sincronizar los relojes.\n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/cris.png)\nHay que tomar ciertas consideraciones en cuenta al momento de usar este algoritmo:\n#### Ventajas\n- Los relojes no deben retroceder para evitar errores\n- La sincronizaci√≥n requiere del intercambio de mensajes, pero el tr√°nsito de estos consume tiempo.\n- El tiempo del receptor UTC no puede ser menor que el tiempo de la m√°quina que le solicit√≥ el tiempo.\n- El servidor de UTC debe procesar las solicitudes de tiempo con el concepto de interrupciones, lo cual incide en el tiempo de atenci√≥n.\n- El intervalo de transmisi√≥n de la solicitud y su respuesta debe ser tomado en cuenta para la sincronizaci√≥n.\n- El tiempo de propagaci√≥n se suma al tiempo del servidor para sincronizar al emisor cuando √©ste recibe la respuesta.\n##### Inconvenientes\n- El problema que se presenta es la posibilidad de fallo debido a la existencia de un √∫nico servidor. Cristian sugiere m√∫ltiples servidores de tiempo sincronizados que suministren el tiempo. El cliente env√≠a un mensaje de petici√≥n a todos los servidores y toma la primera respuesta recibida.\n- El algoritmo no contempla problemas de malfuncionamiento o fraude por parte del servidor.\n- La capacidad de cada nodo para leer el valor del reloj de otro nodo puede generar errores debido al retraso en la comunicaci√≥n de mensajes entre nodos. La demora se puede calcular tomando en cuenta el tiempo necesario para preparar, transmitir y recibir un mensaje vac√≠o en ausencia de errores de transmisi√≥n y carga del sistema.\n### Algoritmo de Berkeley \nEste algoritmo se propone en situaciones en las que no se cuenta con un servidor UTC confiable. La idea es que dentro de las computadoras de una red, se selecciona una que sea maestra y las dem√°s ser√°n esclavas. Esta computadora maestra, se encargar√° de preguntarle a las dem√°s las horas que est√°n manejando, para poder sacar un promedio y mandar instrucciones para el retraso o adelanto de relojes dependiendo la situaci√≥n de cada computadora. \n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/berk.jpg)\n\nEn este algoritmo no es importante tener en cuenta el delay entre el env√≠o y respuesta del mensaje debido a que solo necesitamos hallar un promedio para la sincronizaci√≥n, m√°s no la hora exacta. En caso de que el maestro muera, se busca uno nuevo, y si un nodo falla, simplemente no se toma en cuenta. \n##### Inconvenientes\n- En caso de que el maestro falle, dejar√° de preguntar la hora y, en consecuencia, se perder√° la sincronizaci√≥n.\n- En el paso de mensajes entre maestro y esclavos y viceversa se ha de tener en cuenta el retraso que genera el propio env√≠o de los mensajes, por lo que tendremos errores a la hora de sincronizar.\n- Otro de los problemas de ser un algoritmo centralizado ser√° el de tener que elegir un nuevo maestro debido a que se puedan producir fallos en el tratamiento de los datos para llevar a cabo la sincronizaci√≥n, buscando un maestro que cometa menor cantidad de fallos y el sistema se mantenga en correcto funcionamiento.\n- La demora introducida por los equipos de conmutaci√≥n, se agrava en los casos en los que el equipo cumple otras funciones, adem√°s de conmutar paquetes, como es el caso de un PC que, adem√°s de actuar como conmutador, atiende otras tareas, con lo cual, la misma tarea de conmutar puede insumir diferentes tiempos.\n## NTP\nFinalmente nos encontramos con el protocolo NTP para la sincronizaci√≥n de relojes mediante internet. Este protocolo funciona en la capa 4 de red, **con el protocolo UDP y en el puerto 123.**\n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/ntp.png)\n\n### Funcionamiento\nEl cliente NTP inicia un intercambio de solicitud de tiempo con el servidor NTP. Luego, el cliente puede calcular el retraso del enlace y su compensaci√≥n local y ajustar su reloj local para que coincida con el reloj de la computadora del servidor.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/ntp-3.jpg)\n**La versi√≥n actual es la NTP v4**\n\nComo regla general, se requieren seis intercambios durante un per√≠odo de aproximadamente cinco a 10 minutos para configurar inicialmente el reloj.\n\nUna vez sincronizado, el cliente actualiza el reloj aproximadamente una vez cada 10 minutos, lo que generalmente requiere solo un √∫nico intercambio de mensajes, adem√°s de la sincronizaci√≥n cliente-servidor. Esta transacci√≥n ocurre a trav√©s del Protocolo de datagramas de usuario (UDP) en el **puerto 123** NTP tambi√©n admite la sincronizaci√≥n de transmisi√≥n de los relojes de la computadora del mismo nivel.\n\nHay miles de servidores NTP en todo el mundo. Tienen acceso a relojes at√≥micos de alta precisi√≥n y relojes del Sistema de Posicionamiento Global. Se requieren receptores especializados para comunicarse directamente con los servidores NTP para estos servicios de tiempo. \n\nNo es pr√°ctico ni rentable equipar cada computadora con uno de estos receptores. En cambio, las computadoras designadas como servidores de tiempo principales est√°n equipadas con los receptores. Utilizan protocolos como NTP para sincronizar las horas de reloj de las computadoras en red.\n\nNTP emplea el tiempo universal coordinado (UTC) para sincronizar las horas del reloj de la computadora con extrema precisi√≥n. Ofrece una mayor precisi√≥n en redes m√°s peque√±as, hasta 1 milisegundo en una red de √°rea local (LAN) y dentro de decenas de milisegundos en Internet. NTP no tiene en cuenta las zonas horarias. En cambio, depende del host para realizar tales c√°lculos.\n\nLos grados de separaci√≥n de la fuente UTC se definen como estratos. Los diversos estratos incluyen lo siguiente:\n- Estrato 0. Un reloj de referencia recibe la hora real de un transmisor dedicado o un sistema de navegaci√≥n por sat√©lite. Se clasifica como estrato 0.\n- Estrato 1. Un dispositivo est√° directamente vinculado al reloj de referencia.\n- Estrato 2. Un dispositivo recibe su tiempo de una computadora de estrato 1.\n- Estrato 3. Un dispositivo recibe su tiempo de una computadora de estrato 2.\n\nLa clasificaci√≥n de estrato contin√∫a a partir de ah√≠. La precisi√≥n se reduce con cada grado adicional de separaci√≥n.\n\n### Comparativa V3  vs V4\n - NTPv4  direccionamiento IPv4  e IPv6 cliente ‚Äì servidor\n - Incorporar seguridad en las comunicaciones NTPv4  -\n\t- criptograf√≠a, clave publica y privada\n- Mejora la Compatibilidad con DNS, almacena el nombre del host y la IP, a diferencia de la v3 que le nombre del host no era almacenado\n","lastmodified":"2022-06-29T20:47:29.094860358Z","tags":null},"/Examen2/Seguridad":{"title":"‚å®Ô∏è Seguridad","content":"## DES 56 bit\nDES es el nombre del documento FIPS (Federal Information Processing Standard), es un algoritmo de cifrado por bloques de 64 bits de tama√±o. Emplea una clave de 56 bits durante la ejecuci√≥n.\n- Cuando se utiliza en comunicaciones ambos participantes deben conocer la clave secreta¬†\n- El algoritmo se puede usar para encriptar y desencriptar mensajes,¬†\n- Puede generar y verificar c√≥digos de autentificaci√≥n de mensajes\n- El problema principal es que el tama√±o de la clave (56 bits) es demasiado peque√±o para la potencia de c√°lculo actual. De hecho, el DES dej√≥ de ser el algoritmo empleado por el gobierno norteamericano en noviembre de 1998 y de momento (hasta que el AES sea elegido), emplean el Triple DES\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/des.jpg)\n\n## 3DES\nConsiste en encriptar tres veces una clave DES:\n- DES-EEE3: Tres encriptaciones DES con tres claves distintas.\n\n- Diffie y Hellman propusieron una m√°quina con un coste estimado de 20 millones de d√≥lares que podr√≠a encontrar una clave DES en un solo d√≠a.\n- Wiener sugiri√≥ una m√°quina de b√∫squeda de claves con un coste de un mill√≥n de d√≥lares que encontrar√≠a una clave en 7 horas.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/3des.png)\n## RSA\n- El algoritmo asim√©trico por excelencia\n- Este algoritmo se basa en la pareja de claves\n- La seguridad de este algoritmo radica en el problema de la factorizaci√≥n de n√∫meros enteros muy grandes\n- Actualmente como m√≠nimo se debe utilizar una longitud de 2048 bits, aunque es recomendable que sea de 4096 bits o superior para tener una mayor seguridad.\n- El sistema RSA permite longitudes variables, siendo aconsejable actualmente el uso de claves de no menos de 1024 bits (se han roto claves de hasta 512 bits, aunque se necesitaron m√°s de 5 meses y casi 300 ordenadores trabajando juntos para hacerlo).\n\nEl cifrado RSA funciona bajo la premisa de que el algoritmo es f√°cil de calcular en una direcci√≥n, pero casi imposible en sentido inverso. Como ejemplo, si te dijeran que 701.111 es un producto de dos n√∫meros primos, ¬øser√≠as capaz de averiguar cu√°les son esos dos n√∫meros?\n\n-   En RSA de **2048 bits, se unir√≠an para crear claves de 617 d√≠gitos**\n\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/rsa.png)\n## DIFFIE HELLMAN\nSe usa para generar una clave privada a ambos extremos de un canal de comunicaci√≥n inseguro.\n- Se emplea para obtener la clave privada con la que posteriormente se cifrar√° la informaci√≥n junto con un algoritmo de cifrado sim√©trico.¬†\n- No es un algoritmo asim√©trico propiamente dicho, es un protocolo de establecimiento de claves\n- Su seguridad radica en la dificultad de calcular el logaritmo discreto de n√∫meros grandes\n- El problema de este algoritmo es que no proporciona autenticaci√≥n, no puede validar la identidad de los usuarios, por tanto, si un tercer usuario se pone en medio de la comunicaci√≥n, tambi√©n se le facilitar√≠a las claves y, en consecuencia, podr√≠a establecer comunicaciones con el emisor y el receptor suplantando las identidades.¬†\n- Certificaciones digitales\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/diffi.png)\n## TLS\nTLS se traduce a Transport Layer Security o en espa√±ol Seguridad de la¬†Capa de Transporte y su sucesor SSL¬†\n-   TLS provee una comunicaci√≥n segura entre los navegadores de internet y los servidores. La conexi√≥n en s√≠, es segura gracias a que se usa una criptograf√≠a segura para encriptar los datos transmitidos.\n-   Las llaves son generadas de forma √∫nica por cada conexi√≥n y se basan en un secreto compartido negociado al comienzo de la sesi√≥n, tambi√©n conocido como ‚Äúsaludo de mano TLS‚Äù.\n-   Con la TLS 1.2, se hubieran requerido dos rondas de viaje para completar un saludo de mano TLS.\n-   Con el 1.3, requiere tan solo una ronda de viaje, la cual termina cortando hasta por la mitad la latencia de la encriptaci√≥n.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/tls.png)\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/tls2.webp)\n## HASH\nEs un algoritmo matem√°tico que transforma cualquier bloque arbitrario de datos en una nueva serie de caracteres con una longitud fija.\n-   Independientemente de la longitud de los datos de entrada, el valor hash de salida tendr√° siempre la misma longitud.\n-   No existen dos entradas que produzcan el mismo hash de salida\n- Se utilizan las funciones criptogr√°ficas hash para detectar malware\n- Las funciones criptogr√°ficas hash se utilizan tambi√©n para asegurar la ‚Äúintegridad de los mensajes\n- gesti√≥n de los identificadores y contrase√±as\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/hash.jpg)","lastmodified":"2022-06-29T20:47:29.094860358Z","tags":null},"/Examen2/Tansacciones":{"title":"üí∏ Transacciones","content":"\nUna transacci√≥n es la ejecuci√≥n consistente y confiable de un conjunto de operaciones agrupadas como una unidad que acceden a una base de datos compartida\n\nUna transacci√≥n es una secuencia de una o m√°s operaciones agrupadas como una unidad\n\n## Operaciones at√≥micas\nLas operaciones at√≥micas en programaci√≥n concurrente son operaciones de programa que se ejecutan de forma completamente independiente de cualquier otro proceso.\n\nLas operaciones at√≥micas se utilizan a menudo en el kernel, el componente principal de la mayor√≠a de los sistemas operativos. Sin embargo, la mayor parte del hardware, los compiladores y las bibliotecas de las computadoras tambi√©n proporcionan distintos niveles de operaciones at√≥micas.\n    \n-   Se dice que una operaci√≥n es at√≥mica cuando se completa de principio a fin sin interrupciones.\n\n-   Java garantiza que son at√≥micos los accesos a las variables de tipos primitivos, excepto double y long\n\nLas operaciones que contiene una transacci√≥n se van almacenando temporalmente, no a nivel de disco. Es hasta que termina la transacci√≥n que se tienen efecto de manera permanente o no\n\nEn algunas situaciones, el cliente necesita que una secuencia de solicitudes al servidor se ejecuten de manera at√≥mica:\n\n- Libres de interferencia por operaciones de otros clientes\n- Todas las operaciones se deben completar con √©xito o no tener ning√∫n efecto si el servidor falla.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/tra.jpg)\n### Caracter√≠sticas\n- El manejo de transacciones puede venir como parte del middleware que proporciona la especificaci√≥n para un servicio de transacciones sobre objetos.\n- Una transacci√≥n aplica a datos recuperables, puede estar formada por operaciones simples o compuestas y su intenci√≥n es que sea at√≥mica.\n- Hay dos aspectos que se deben cumplir para lograr la atomicidad: todo-o-nada, aislamiento.\n- Una transacci√≥n siempre termina, aun en la presencia de fallas. Si una transacci√≥n termina de manera exitosa se dice que la transacci√≥n hace un commit.\n- Cuando la transacci√≥n es abortada, su ejecuci√≥n se detiene y todas las acciones ejecutadas hasta el momento se deshacen (undone) regresando a la base de datos al estado antes de su ejecuci√≥n. **rollback**\n\n## Propiedades de las transacciones ACID\n1. Atomicidad **atomicity**\n2. Consistencia **consistency**\n3. Aislamiento **isolation**\n4. Durabilidad **durability**\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/acid.jpg)\n### Atomicidad\nAseguran que todas las operaciones dentro de la secuencia de trabajo se completen satisfactoriamente. Si no es as√≠, la transacci√≥n se abandona en el punto del error y las operaciones previas retroceden a su estado inicial.\n**TODO O NADA**\n\n### Consistencia\nAseguran que la base de datos cambie estados en una transacci√≥n exitosa.\n\n#### Aislamiento\nPermiten que las operaciones sean aisladas y transparentes unas de otras. **Sin interferencias**\n\n### Durabilidad\nUna vez que una transacci√≥n se completa correctamente, sus efectos no se pueden modificar sin ejecutar una transacci√≥n de compensaci√≥n. Los cambios realizados por una transacci√≥n correcta sobreviven a posteriores anomal√≠as del sistema.\n\n## Tipos\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/tras.jpg)\n### Planas\nEstas transacciones tienen un punto de partida simple **Begin** y **End**\n\n### Anidadas\n- Las operaciones de una transacci√≥n anidada pueden incluir otras transacciones.\n\n- Una transacci√≥n anidada dentro de otra transacci√≥n conserva las mismas propiedades que la de sus padres, esto implica, que puede contener as√≠ mismo transacciones dentro de ella.\n#### Restricciones de las anidadas\n- Debe empezar despu√©s que su padre y debe terminar antes que √©l.\n- El commit de una transacci√≥n padre est√° condicionada al commit de sus transacciones hijas\n- Si alguna transacci√≥n hija aborta (rollback), la transacci√≥n padre tambi√©n ser√° abortada (rollback).\n## Bit√°cora\n- Es un archivo que permite deshacer las operaciones realizadas sobre una o varias bases de datos en caso de que falle la transacci√≥n.\n- Esto se hace con el fin de mantener la integridad de la informaci√≥n y que la transacci√≥n sea at√≥mica\n\n## Seguridad en transacciones\n1. Autenticaci√≥n: asegura la identidad del servidor participante en la comunicaci√≥n.\n2. Confidencialidad: asegura que la informaci√≥n transmitida en la comunicaci√≥n entre el cliente y el servidor s√≥lo sea legible por estas dos entidades.\n3. Integridad: asegura que la informaci√≥n transmitida en la comunicaci√≥n entre el cliente y el servidor no haya sido alterada en su viaje por la red\n\nSSL ‚Äì SECURE SOCKET LAYER\nSET ‚Äì SECURE ELECTRONIC TRANSACTION \n\tEs un sistema que garantiza la seguridad e integridad \n     de las transacciones electr√≥nicas realizadas en un escenario. \n     SET no es un sistema que permita el pago, pero es un protocolo de seguridad aplicado a esos pagos. Utiliza diferentes t√©cnicas de encriptaci√≥n y hash para asegurar los pagos a trav√©s de Internet a trav√©s de tarjetas de cr√©dito. Este protocolo fue apoyado en el desarrollo por las principales organizaciones como Visa, Mastercard.\n","lastmodified":"2022-06-29T20:47:29.094860358Z","tags":null},"/Examen2/VPNIPsec":{"title":"ü§´ VPN IPsec","content":"## VPN\nUna red privada virtual (VPN, por sus siglas en ingl√©s) es una tecnolog√≠a que permite a los usuarios enviar y recibir datos a trav√©s de redes compartidas o p√∫blicas, como si sus equipos inform√°ticos estuvieran conectados directamente a la red privada. \n\nUn protocolo de tunelizaci√≥n es un protocolo que encapsula en su datagrama otro paquete de datos completo que utiliza un protocolo de comunicaciones diferente. Esencialmente, crea un t√∫nel entre dos puntos de una red por el cual se puede transmitir de forma segura cualquier tipo de datos.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/vpn.png)\n## IPsec\nIPsec es un tipo de protocolo que ofrece un conjunto de est√°ndares para que se piensa una conexi√≥n VPN. Este protocolo permite encriptar los paquetes que se env√≠an para que viaje por ese t√∫nel y llegue al otro punto de manera segura, este protocolo cubre los siguientes puntos:\n-   Autenticaci√≥n de origen de datos: Verifica si el origen de los paquetes son realmente el origen indicado.\n-   Integridad de los datos: Comprueba si el paquete es exactamente igual a como salieron el origen.¬†\n-   Confidencialidad de los datos: Significa que oculto el contenido por un cifrado.\n-   Protecci√≥n de reproducci√≥n: Impide que los paquetes puedan ser interceptados y despu√©s volverlos a reproducir.\n-   Gesti√≥n automatizada de claves criptogr√°ficas y asociaciones de seguridad: Permite utilizar VPN sin configuraci√≥n manual o con muy poca.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/ipsec.jpg)\n## Protocolos\nLos protocolos que usa para las cabeceras y para el cuerpo son los siguientes\n\n-   AH: protocolo de cabecera de autenticaci√≥n, ofrece protecci√≥n de reproducci√≥n, integridad de los datos y autenticaci√≥n del origen de los datos, pero este no ofrece confidencialidad, por lo que los datos son enviados en texto plano.\n    \n-   ESP: Ofrece la confidencialidad de los datos que no ofrece AH y de tambi√©n puede ofrecer autenticaci√≥n del origen de los datos, protecci√≥n contra la reproducci√≥n y comprobaci√≥n de la integridad.\n\nEste protocolo implica cinco componentes principales:\n-   Protocolos de seguridad: Los datagramas son protegidos con los dos protocolos mencionados y explicados anteriormente.\n-   Base de datos de asociaciones de seguridad (SADB): Esta base de datos es la que asocia un protocolo de seguridad con la direcci√≥n de destino IP y un n√∫mero de √≠ndice. La base de datos garantiza que se pueda reconocer un paquete que llega a su destino debidamente protegido.\n-   Administraci√≥n de claves: La distribuci√≥n y generaci√≥n de claves para los algoritmos criptogr√°ficos y SPI\n-   Mecanismos de seguridad:Los algoritmos de cifrado y autenticaci√≥n que protegen los datos de los datagramas IP.\n-   Base de datos de directivas de seguridad (SPD): Esta base de datos especifica el nivel de protecci√≥n que se aplicar√° a un paquete, este filtra el tr√°fico IP para que se pueda hallar el modo en el que se procesaran los paquetes.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/ipsecp.png)\n## Fases\nLas negociaciones IPsec se dan en dos fases: \n- Fase 1, en esta fase se crea un canal seguro para negociar la asociaci√≥n de seguridad IPsec(SA) \n- Fase 2, los participantes negocian esta SA para la autenticaci√≥n del tr√°fico que pasa en este t√∫nel.\n![Caracteristicas](/sistemas-distribuidos/Examen2/images/ipsecphas.jpg)","lastmodified":"2022-06-29T20:47:29.094860358Z","tags":null},"/Examen3/Comunicacion":{"title":"üíå Comunicacion orientada a mensajes","content":"La comunicaci√≥n entre procesos es el n√∫cleo de todos los sistemas distribuidos *Tanenbaum \u0026 Van Steen, 2008*, por tal raz√≥n es importante entender la manera en que los procesos localizados en diferentes computadoras pueden intercambiar informaci√≥n. \n\nLa comunicaci√≥n entre procesos necesita compartir informaci√≥n:\n1. datos compartidos\n2. Pasajes de mensajes o copias compartidas\n\nEn los sistemas distribuidos tradicionalmente la comunicaci√≥n est√° basada en el paso de mensaje. Esta t√©cnica aporta sincronizaci√≥n entre procesos y permite la exclusi√≥n mutua, su principal caracter√≠stica es que no requiere memoria compartida, por lo que resulta ser muy relevante en la programaci√≥n de sistemas distribuidos.\n\n## Tipos de comunicaci√≥n\n### Comunicaci√≥n PERSISTENTE: \nAlmacena el mensaje (informaci√≥n) enviado por el emisor el tiempo que tome entregarlo al receptor.\n\n### Comunicaci√≥n TRANSITORIA\nAlmacena un mensaje solo mientras las aplicaciones del emisor y receptor est√°n en ejecuci√≥n.\n\n### Comunicaci√≥n ASINCR√ìNICA \nEl emisor contin√∫a inmediatamente despu√©s de que ha pasado su mensaje para la transmisi√≥n\n\n### Comunicaci√≥n SINCR√ìNICA \nEl emisor es bloqueado hasta que se sabe que su petici√≥n es aceptada\n\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/pers.jpg)\n\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/ps.jpg)\n\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/tras.png)\n## Paradigmas de comunicaci√≥n\n### Comunicaci√≥n directa\nLas primitivas enviar y recibir  usan directamente el nombre del proceso con el que se comunican. \n\n### Comunicaci√≥n indirecta\nLas operaciones b√°sicas Send y Receive se definen de la siguiente manera: Send (P, mensaje); env√≠a un mensaje al proceso P. Receive (Q, mensaje); espera la recepci√≥n de un mensaje por parte del proceso Q.\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/direct.png)\n## Comunicaci√≥n RPC\nLa RPC o Remote Procedure Call (en espa√±ol, llamada a procedimiento remoto) es una herramienta b√°sica para establecer estructuras colaborativas y operativas en redes y arquitecturas cliente-servidor. \n\nEl proceso de comunicaci√≥n con RPC consta del env√≠o de par√°metros y el retorno de un valor de funci√≥n. A menudo, no se limita a una sola llamada, ya que en la pr√°ctica se procesan muchas solicitudes en paralelo.\n\nLa idea de RPC es que una llamada a un procedimiento remoto se parezca lo m√°s posible a una llamada local, esto le permite una mayor transparencia. Para ello, el RPC usa una instancia del cliente que se encarga de empacar los par√°metros en un mensaje y le solicita al n√∫cleo que env√≠e el mensaje al servidor, posteriormente se bloquea hasta que regrese la respuesta. \n![Caracteristicas](/sistemas-distribuidos/Examen3/images/rpc.png)\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/rpc2.png)\n## Multidifusi√≥n Multicast\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/mult.jpg)\n### Objetivo\nentrega de mensajes a un grupo de procesos distribuidos, garantizando\n-\tFiabilidad: todos los procesos del grupo reciben el mensaje\n-\tOrden: el orden de entrega del mensaje es acordado y se respeta\n### Fundamento\n-\tUn proceso realiza solo una operaci√≥n multicast para enviar un\n\tmensaje a todos los miembros del grupo\n-\tUn proceso obtiene mensajes mediante una orden entrega, que no\n\timplica una recepci√≥n instant√°nea del mensaje\n### Multidifusi√≥n b√°sica\n- **Envuelven** a las operaciones de env√≠o y recepci√≥n \n- Los procesos pueden pertenecer a varios grupos\n- Cada mensaje se destina a un grupo en particular\n\nEjemplo: hilos para env√≠o concurrente\n\n## Multidifusi√≥n fiable\nDebe cumplir con las condiciones de:\n- Integridad: un proceso entrega un mensaje a lo sumo una vez\n- Validez: todo mensaje multidifundido es entregado al remitente\n\t- Garantiza que el remitente sigue vivo tras la multidifusi√≥n\n- Acuerdo: si un proceso recibe un mensaje, todo el grupo lo recibe\n\t-\tConcepto de ‚Äúatomicidad‚Äù: o todos, o ninguno\n\t-\tEsta condici√≥n no se cumple en B-multicast, que solo garantiza la comunicaci√≥n fiable uno a uno.\n\n","lastmodified":"2022-06-29T20:47:29.106860445Z","tags":null},"/Examen3/Replicacion":{"title":"üü£ Replicacion","content":"Mantenimiento de copias de la informaci√≥n en m√∫ltiples computadores\n- Es un recurso utilizado ampliamente en sistemas distribuidos\n- Servidores web: servidores cach√© y proxies\n- DNS: copias de los mapeos URL-IP, actualizadas diariamente\n- Google: Google Data Centers\nAyuda a mejorar un SD en distintos aspectos:\n- Rendimiento\n- Disponibilidad\n- Tolerancia a fallos\n\n- Se da principalmente a trav√©s de cach√©s en clientes o servidores\n- Mantener copias de los resultados obtenidos en llamadas anteriores al servicio reduce el coste de llamadas id√©nticas. Evita el tiempo de latencia del c√°lculo del resultado o de las consultas a otros servidores\n- La replicaci√≥n de datos inmutables es trivial\n- La replicaci√≥n de datos cambiantes (frecuentes en la red) conlleva un coste en protocolos de intercambio y actualizaci√≥n, que pueden limitar la efectividad de la r√©plica\n\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/replica.jpg)\n## Transparencia\nLos clientes no son conscientes de que hay m√∫ltiples copias del recurso al que acceden para los clientes, solo existen recursos l√≥gicos individuales\n\n## Consistencia\nLas operaciones sobre un conjunto de objetos replicados deben dar resultados que sigan \n la especificaci√≥n de correcci√≥n definida para dichos objetos\n\n## Objeto\nCualquier entidad de informaci√≥n a replicar: Archivos, objetos Java, etc.\n\n## Objeto l√≥gico\nEntidad de informaci√≥n visible por el usuario, implementada por distintas copias f√≠sicas o r√©plicas. Las r√©plicas de un objeto l√≥gico no tienen por qu√© ser todas\niguales en todo momento.\n\nEjemplo: algunas pueden haberse actualizado y otras no\n- Sistema as√≠ncrono\n- Los procesos fallan solo por ca√≠da\n\n## Gestor de r√©plicas\nComponentes que almacenan r√©plicas de un determinado objeto o servicio y operan sobre ellas.\n## Frontal\nComponente que atiende las llamadas de los clientes y se comunica con los gestores de r√©plicas.\n\n## Petici√≥n\n1. Petici√≥n: El frontal env√≠a la petici√≥n a un gestor o bien env√≠a la petici√≥n a un gestor y este reenv√≠a a otros o multidifunde la petici√≥n a varios gestores\n2. Coordinaci√≥n: los gestores se coordinan para ejecutar la petici√≥n de manera consistente\n3. Ejecuci√≥n: se ejecuta la petici√≥n (puede ser de forma tentativa)\n4. Acuerdo: se llega a un consenso antes de consumar la ejecuci√≥n\n5. Respuesta: uno o m√°s gestores de r√©plicas responden al frontal\n\n## Tolerancia a fallos\n- Una alta disponibilidad no implica necesariamente correcci√≥n\n- Puede haber datos no actualizados, o inconsistentes (concurrencia)\n- Podemos utilizar replicaci√≥n para ganar tolerancia a fallos, parada o ca√≠da\n- Si tenemos n servidores, pueden fallar n-1 sin alterar el servicio\n- Fallo bizantino:c\n\nDeben proporcionar un servicio correcto, aunque fallen n procesos, mediante la replicaci√≥n de datos y la funcionalidad asociada a los gestores de r√©plicas, de dos modelos principales:\n- Replicaci√≥n pasiva o primario-respaldo\n- Replicaci√≥n activa\n\n### Replicaci√≥n pasiva\nUn gestor de r√©plicas primario y uno o m√°s gestores secundarios (‚Äòrespaldos‚Äô o ‚Äòesclavos‚Äô)\n- Los frontales solo se comunican con el gestor primario\n- Ejecuta las operaciones y manda copias a los respaldos\n- Si el primario falla, uno de los respaldos promociona a primario\n\n#### Fases\n1. Petici√≥n: el frontal env√≠a la petici√≥n al gestor primario\n2. Coordinaci√≥n: el gestor primario ejecuta las peticiones siguiendo una ordenaci√≥n FIFO\n3. Ejecuci√≥n: se ejecuta la petici√≥n y se almacena la respuesta\n4. Acuerdo: si es una petici√≥n de actualizaci√≥n, el gestor primario env√≠a la actualizaci√≥n a todos los respaldos, que confirman la recepci√≥n\n5. Respuesta: el gestor primario responde al frontal\n\n#### An√°lisis\n- Tolera fallos de proceso (gestor primario o respaldos)\n- No tolera fallos bizantinos\n- El frontal requiere poca funcionalidad\n- Al controlar el orden de modificaci√≥n mediante el gestor primario, mantiene la consistencia secuencial\n- Problemas de cuello de botella en el gestor primario\n- Actualizaci√≥n de todos los respaldos antes de dar respuesta\n- Los respaldos no dan servicio directo\n\n### Replicaci√≥n Activa\nTodos los gestores de r√©plicas tienen el mismo papel los frontales multidifunden las peticiones a todos los gestores,  los gestores de r√©plicas procesan la petici√≥n de manera independiente, pero id√©ntica.\n\n#### Fases\n1. Petici√≥n: el frontal multidifunde la petici√≥n a los gestores. Se utiliza multidifusi√≥n fiable y de ordenaci√≥n total*. No env√≠a otra petici√≥n hasta que recibe la respuesta a la actual\n2. Coordinaci√≥n: el sistema de comunicaci√≥n entrega la petici√≥n a todos los gestores seg√∫n una ordenaci√≥n total (multidifusi√≥n)\n3. Ejecuci√≥n: cada gestor ejecuta la petici√≥n\n4. Acuerdo: no es necesaria, debido al tipo de multidifusi√≥n\n5. Respuesta: cada gestor manda su respuesta al frontal. El n¬∫ de respuestas que recoge el frontal depende de las asunciones de fallo y del algoritmo de multidifusi√≥n\n\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/rdp2.png)\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/rdp.png)\n\n## Alta disponibilidad\nLa proporci√≥n de tiempo que un servicio est√° accesible con tiempos de respuesta razonables debe ser ~ 100%\n- Factores de p√©rdida de disponibilidad\n- Fallos en el servidor\n- Si un servidor tiene una posibilidad de fallo p del 5%, tendr√° disponibilidad del 95%\n\t- Si replicamos n veces el servidor, la disponibilidad ser√° 1-pn \n\t- Con n=2 servidores: 1 - 0.052 = 99.75%\n- Particiones de red o desconexiones\n- Desconexi√≥n intencionada (p. ej. BitTorrent) o no intencionada (p. ej. conexi√≥n inal√°mbrica viajando en bus)\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/disp.png)\n### Convergencia\nTodas las r√©plicas del documento tienen que ser iguales tras aplicar todas las operaciones.\n### Consistencia\nLas operaciones deben aplicarse en el mismo orden en todos los nodos\n- Bas√°ndose en la relaci√≥n ‚Äòsucede antes que‚Äô\n- No lo garantiza TO ‚Üí uso de ordenaci√≥n causal\n#### Intenci√≥n\nEl efecto de ejecutar una operaci√≥n debe ser el mismo que el efecto buscado en la r√©plica local sobre la que se aplica inicialmente.\n\n## Consenso por Quorum\n#### Operaci√≥n de lectura\n- Recuperar un qu√≥rum de lectura (cualquier conjunto de r copias)\n- De las r copias, seleccionar la copia con el n.¬∫ de versi√≥n m√°s alto\n- Retornar el valor de dicha copia\n#### Operaci√≥n de escritura\n- Tomar un qu√≥rum de escritura (cualquier conjunto de w copias)\n- De las w copias, obtener el n.¬∫ de versi√≥n m√°s alto\n- Incrementar el n¬∫ de versi√≥n\n- Escribir el nuevo valor y el nuevo n.¬∫ de versi√≥n en todas las w copias del qu√≥rum de escritura\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/quo.webp)\n## Cl√∫ster\nEste tipo de sistemas se basa en la uni√≥n de varios servidores que trabajan como si de uno √∫nicamente se tratase. Los sistemas cl√∫ster han evolucionado mucho desde su primera aparici√≥n, ahora se pueden crear distintos tipos de cl√∫steres, en funci√≥n de lo que se necesite:\n- Uni√≥n de Hardware\n- Cl√∫steres de Software\n- Alto rendimiento de bases de datos\n\n![Caracteristicas](/sistemas-distribuidos/Examen3/images/cluster.png)\nEstas son solo algunas de las opciones que tenemos disponibles. En resumen, cluster es un grupo de m√∫ltiples ordenadores unidos mediante una red de alta velocidad, de tal forma que el conjunto es visto como un √∫nico ordenador, m√°s potente que los comunes de escritorio\n\n- Alto rendimiento\n- Alta disponibilidad\n- Equilibrio de carga\n- Escalabilidad\n### Ventajas\n- Relaci√≥n costo/performance.\n- Escalabilidad incremental.\n- Escalabilidad incremental.\n- Sistema ‚Äúmultiprop√≥sito‚Äù (no dedicado)\n\n#### DESVENTAJAS\nNinguna, este tipo de sistemas son los m√°s fiables, ya que para la parada total del proceso deben de pararse todas las m√°quinas que componen el grupo. Es la mejor soluci√≥n para crecer seg√∫n las necesidades reales, porque puede a√±adir tantas m√°quinas necesite.\n\n### Qu√© necesita para servir\nPor norma general, un cl√∫ster hace uso de diferentes componentes para funcionar, entre estos est√°n:\n- Nodos (Ordenadores o servidores)\n- Sistema operativo\n- Conexi√≥n de Red (ampliado m√°s abajo)\n- Middleware (capa entre el usuario y el sistema operativo)\n- Protocolos de comunicaci√≥n y servicio\n- Aplicaciones\n\n\n\n\n","lastmodified":"2022-06-29T20:47:29.106860445Z","tags":null},"/Examen3/images/direct.jpg":{"title":"","content":"","lastmodified":"2022-06-29T20:47:29.106860445Z","tags":null},"/Untitled":{"title":"","content":"","lastmodified":"2022-06-29T20:47:29.110860474Z","tags":null},"/cheatsheet":{"title":"","content":"# Markdown Cheat Sheet\n\nThanks for visiting [The Markdown Guide](https://www.markdownguide.org)!\n\nThis Markdown cheat sheet provides a quick overview of all the Markdown syntax elements. It can‚Äôt cover every edge case, so if you need more information about any of these elements, refer to the reference guides for [basic syntax](https://www.markdownguide.org/basic-syntax) and [extended syntax](https://www.markdownguide.org/extended-syntax).\n\n## Basic Syntax\n\nThese are the elements outlined in John Gruber‚Äôs original design document. All Markdown applications support these elements.\n\n### Heading\n\n# H1\n## H2\n### H3\n\n### Bold\n\n**bold text**\n\n### Italic\n\n*italicized text*\n\n### Blockquote\n\n\u003e blockquote\n\n### Ordered List\n\n1. First item\n2. Second item\n3. Third item\n\n### Unordered List\n\n- First item\n- Second item\n- Third item\n\n### Code\n\n`code`\n\n### Horizontal Rule\n\n---\n\n### Link\n\n[Markdown Guide](https://www.markdownguide.org)\n\n### Image\n\n![alt text](https://www.markdownguide.org/assets/images/tux.png)\n\n## Extended Syntax\n\nThese elements extend the basic syntax by adding additional features. Not all Markdown applications support these elements.\n\n### Table\n\n| Syntax | Description |\n| ----------- | ----------- |\n| Header | Title |\n| Paragraph | Text |\n\n### Fenced Code Block\n\n```\n{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"age\": 25\n}\n```\n\n### Footnote\n\nHere's a sentence with a footnote. [^1]\n\n[^1]: This is the footnote.\n\n### Heading ID\n\n### My Great Heading {#custom-id}\n\n### Definition List\n\nterm\n: definition\n\n### Strikethrough\n\n~~The world is flat.~~\n\n### Task List\n\n- [x] Write the press release\n- [ ] Update the website\n- [ ] Contact the media\n\n### Emoji\n\nThat is so funny! :joy:\n\n(See also [Copying and Pasting Emoji](https://www.markdownguide.org/extended-syntax/#copying-and-pasting-emoji))\n\n### Highlight\n\nI need to highlight these ==very important words==.\n\n### Subscript\n\nH~2~O\n\n### Superscript\n\nX^2^","lastmodified":"2022-06-29T20:47:29.110860474Z","tags":null},"/dns":{"title":"üí´ DNS","content":"\n## Prerequisitos\nTener aptitude\n```\napt-get install aptitude\n```\n\n## Instalar Bind9\n```\naptitude install bind9 bind9-dnsutils bind9utils\n```\nEl archivo por defecto esta en \n```\ndpkg -s bind9\n```\n### DNS\nEditar el conf\n```\nvim named.conf.local\n```\ncopiar el default para nuestra propia zona\n```\ncp db.0 /var/lib/bind/servidores.com.zone\n```\neditarlo\n```\nvim /var/lib/bind/servidores.com.zone\n```\n\nPara comprobar se puede usar nslookup y dig","lastmodified":"2022-06-29T20:47:29.110860474Z","tags":null},"/notes/CJK-+-Latex-Support-%E6%B5%8B%E8%AF%95":{"title":"CJK + Latex Support (ÊµãËØï)","content":"\n## Chinese, Japanese, Korean Support\nÂá†‰πéÂú®Êàë‰ª¨ÊÑèËØÜÂà∞‰πãÂâçÔºåÊàë‰ª¨Â∑≤ÁªèÁ¶ªÂºÄ‰∫ÜÂú∞Èù¢„ÄÇ\n\nÏö∞Î¶¨Í∞Ä Í∑∏Í≤ÉÏùÑ ÏïåÍ∏∞ÎèÑ Ï†ÑÏóê Ïö∞Î¶¨Îäî ÎïÖÏùÑ Îñ†ÎÇ¨ÏäµÎãàÎã§.\n\nÁßÅ„Åü„Å°„Åå„Åù„Çå„ÇíÁü•„Çã„Åª„ÅºÂâç„Å´„ÄÅÁßÅ„Åü„Å°„ÅØÂú∞Èù¢„ÇíÈõ¢„Çå„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ\n\n## Latex\n\nBlock math works with two dollar signs `$$...$$`\n\n$$f(x) = \\int_{-\\infty}^\\infty\n    f\\hat(\\xi),e^{2 \\pi i \\xi x}\n    \\,d\\xi$$\n\t\nInline math also works with single dollar signs `$...$`. For example, Euler's identity but inline: $e^{i\\pi} = 0$\n\nAligned equations work quite well:\n\n$$\n\\begin{aligned}\na \u0026= b + c \\\\ \u0026= e + f \\\\\n\\end{aligned}\n$$\n\nAnd matrices\n\n$$\n\\begin{bmatrix}\n1 \u0026 2 \u0026 3 \\\\\na \u0026 b \u0026 c\n\\end{bmatrix}\n$$\n\n## RTL\nMore information on configuring RTL languages like Arabic in the [config](notes/config.md) page.\n","lastmodified":"2022-06-29T20:47:29.110860474Z","tags":null},"/notes/hosting":{"title":"Deploying Quartz to the Web","content":"\n## GitHub Pages\nQuartz is designed to be effortless to deploy. If you forked and cloned Quartz directly from the repository, everything should already be good to go! Follow the steps below.\n\n### Enable GitHub Actions\nBy default, GitHub disables workflows from running automatically on Forked Repostories. Head to the 'Actions' tab of your forked repository and Enable Workflows to setup deploying your Quartz site!\n\n![Enable GitHub Actions](notes/images/github-actions.png)*Enable GitHub Actions*\n\n### Enable GitHub Pages\n\nHead to the 'Settings' tab of your forked repository and go to the 'Pages' tab.\n\n1. (IMPORTANT) Set the source to deploy from `master` (and not `hugo`) using `/ (root)`\n2. Set a custom domain here if you have one!\n\n![Enable GitHub Pages](/notes/images/github-pages.png)*Enable GitHub Pages*\n\n### Pushing Changes\nTo see your changes on the internet, we need to push it them to GitHub. Quartz is a `git` repository so updating it is the same workflow as you would follow as if it were just a regular software project.\n\n```shell\n# Navigate to Quartz folder\ncd \u003cpath-to-quartz\u003e\n\n# Commit all changes\ngit add .\ngit commit -m \"message describing changes\"\n\n# Push to GitHub to update site\ngit push origin hugo\n```\n\nNote: we specifically push to the `hugo` branch here. Our GitHub action automatically runs everytime a push to is detected to that branch and then updates the `master` branch for redeployment.\n\n### Setting up the Site\nNow let's get this site up and running. Never hosted a site before? No problem. Have a fancy custom domain you already own or want to subdomain your Quartz? That's easy too.\n\nHere, we take advantage of GitHub's free page hosting to deploy our site. Change `baseURL` in `/config.toml`.\n\nMake sure that your `baseURL` has a trailing `/`!\n\n[Reference `config.toml` here](https://github.com/jackyzha0/quartz/blob/hugo/config.toml)\n\n```toml\nbaseURL = \"https://\u003cYOUR-DOMAIN\u003e/\"\n```\n\nIf you are using this under a subdomain (e.g. `\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz`), include the trailing `/`.\n\n```toml\nbaseURL = \"https://\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz/\"\n```\n\nChange `cname` in `/.github/workflows/deploy.yaml`. Again, if you don't have a custom domain to use, you can use `\u003cYOUR-USERNAME\u003e.github.io`.\n\nPlease note that the `cname` field should *not* have any path `e.g. end with /quartz` or have a trailing `/`.\n\n[Reference `deploy.yaml` here](https://github.com/jackyzha0/quartz/blob/hugo/.github/workflows/deploy.yaml)\n\n```yaml\n- name: Deploy  \n  uses: peaceiris/actions-gh-pages@v3  \n  with:  \n\tgithub_token: ${{ secrets.GITHUB_TOKEN }} # this can stay as is, GitHub fills this in for us!\n\tpublish_dir: ./public  \n\tpublish_branch: master\n\tcname: \u003cYOUR-DOMAIN\u003e\n```\n\nHave a custom domain? [Learn how to set it up with Quartz ](notes/custom%20Domain.md).\n\n---\n\nNow that your Quartz is live, let's figure out how to make Quartz really *yours*!\n\nüé® [Customizing Quartz](notes/config.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-06-29T20:47:29.110860474Z","tags":null},"/practicas/alias":{"title":"üëΩ Alias","content":"\n## Prerequisitos\ninstalar vim\n```\napt-get install vim\n```\n\n## Agregar alias\nIr a:\n```\nvim ~/.bashrc\n```\n\nEn la parte izquierda estara el nombre de nuestro alias y en la derecha el comando al cual nos referimos\n```\nalias ll='ls -l'\n```","lastmodified":"2022-06-29T20:47:29.114860503Z","tags":null},"/practicas/apache":{"title":"üï∏Ô∏è Apache","content":"\n## Prerequisitos\nTener aptitude\n```\napt-get install aptitude\n```\nTener un segundo disco\n## Instalar apache2\n```\naptitude install apache2\n```\n```\ndpkg -s apache2\n```\ndarle permisos a /var/www\n```\nchmod 755 -R /var/www/\n```\n\nY ya deberia estar corriendo, si se va a nuestra ip en el navegador aparecera la pagina de apache por defecto, la cual esta en /var/www/html/index.html.\n\n## Agregar paginas\ncrear nuestra carpeta e index para nuestra nueva pagina, editar el index\n```\nmkdir /var/www/nuevapag\n```\n```\nvim /var/www/nuevapag/index.html\n```\nCopiar el default conf para la nueva pagina\n```\ncp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/nuevapag.com.conf\n```\neditar el archivo\n```\nvim /etc/apache2/sites-available/nuevapag.com.conf\n```\n\ndonde dice virtual host se puede cambiar el puerto de este por defecto esta 80\n```\n\u003cVirtualHost *:80\u003e\n```\n\ntambien se puede poner un nombre para no solo ingresar por ip\n```\nServerName www.nuevapag.com\n```\nCambiar el DocumentRoot al creado\n```\nDocumentRoot /var/www/nuevapag\n```\nAgregar el sitio\n```\na2ensite nuevapag.com.conf\n```\n\nSi se agrego un servername agregar a /etc/hosts\n```\nvim /etc/hosts\n```\n```\ntu-ip www.nuevapag.com\n```\nejemplo\n```\n192.168.34.122 www.nuevapag.com\n```\nSi se cambio el puerto agregar un listen al puerto correspondienteen /etc/apache2/ports.conf\n```\nvim /etc/apache2/ports.conf\n```\n```\nListen 891\n```\n## Importante\nReiniciar el apache2\n```\nsystemctl restart apache2\n```","lastmodified":"2022-06-29T20:47:29.114860503Z","tags":null},"/practicas/discosduros":{"title":"üíæ Alias","content":"\n## Prerequisitos\nTener un disco duro aparte del de el sistema, se pueden a√±adir en configuracion\n\n## A√±adir discos\nPara ver los discos que hay\n```\nlsblk\n```\no\n```\nfdisk -l\n```\na√±adir al sdb una particion\n```\nfdisk /dev/sdb\n```\ndentro de la consola fdisk\nponer n para agregar particion\n```\nn\n```\nluego, p para primaria y e para extendida\n```\np\n```\no\n```\ne\n```\nluego enter por default se pondra el numero de particion\nde nuevo enter para el promer sector esta por default\n\nPoner cuanto de memoria se necesita, ejemplo 5GB\n```\n+5GB\n```\n\nfinalmente guardar y salir\n```\nwq\n```\n\nDarle formato a la particion\n```\nmkfs.ext4 /dev/sdb1\n```\nhacer un directorio en /mnt/discob1\n```\nmkdir /mnt/discob1\n```\nmontar el disco\n```\nmount /dev/sdb1/ /mnt/discob1\n```\nSi se quiere montarlo cada vez que se inicia la maquina a√±adirlo en el fstab\n```\nvim /etc/fstab\n```","lastmodified":"2022-06-29T20:47:29.114860503Z","tags":null},"/practicas/lvm":{"title":"üíΩ LVM","content":"\n## Prerequisitos\nTener aptitude\n```\napt-get install aptitude\n```\nTener un segundo disco\n## Instalar lvm\n```\naptitude install lvm2\n```\n```\ndpkg-query -s lvm2\n```\n## Crear LVM\nCrear un physical volume\n```\npvcreate /dev/sdb\n```\n```\npvs\n```\nCrear un volume group\n```\nvgcreate grupo /dev/sdb\nvgs\n```\nVer ambos\n```\npvdisplay\nvgdisplay\n```\nCrear logic volumen, en este caso de 10Gb y de nombre music, en el volume group grupo\n```\nlvcreate -L 10G -n music grupo\n```\n```\nlvs\n```\nDarle formato ext4\n```\nmkfs.ext4 /dev/grupo/music\n```\nCrear un directorio en el /mnt/\n```\nmkdir /mnt/lvm\n```\nmontar el disco\n```\nmount /dev/grupo/music /mnt/lvm/\n```\n\n### Extend\nAgregar el /dev/sdc a grupo\n```\nvgextend grupo /dev/sdc\n```\nAgregar a /dev/grupo/music 5Gb\n```\nlvextend -L+5G /dev/grupo/music\n```","lastmodified":"2022-06-29T20:47:29.114860503Z","tags":null},"/practicas/nginx":{"title":"üí´ Nginx","content":"\n## Prerequisitos\nTener aptitude\n```\napt-get install aptitude\n```\n\n## Instalar Nginx\n```\naptitude install  nginx\n```\nEl archivo por defecto esta en \n```\n/usr/share/nginx/html/index.html\n```\n\n### A√±adir pagina\nA√±adir carpeta y su index\n```\nmkdir /var/www/nuevapag.com\n```\ndar permisos\n```\nchmod -R 755 /var/www/\n```\n\nCopiar el archivo de configuracion\n\n```\ncp /etc/nginx/sites-available/default /etc/nginx/sites-available/nuevapag.com\n```\n\nEditar el archivo\n```\nvim  /etc/nginx/sites-available/nuevapag.com\n```\n\nRealizar el link\n```\nln -s /etc/nginx/sites-available/nuevapag.com /etc/nginx/sites-enabled/\n```\n\n### importante\nAgregar en /etc/hosts si se puse nombre de seridor\n```\nvim /etc/hosts\n```\nReiniciar nginx\n```\n/etc/init.d/nginx restart\n```\n\n\n","lastmodified":"2022-06-29T20:47:29.114860503Z","tags":null},"/practicas/samba":{"title":"üè° Samba","content":"\n## Prerequisitos\nTener aptitude\n```\napt-get install aptitude\n```\nTener un segundo disco\n## Instalar samba\n```\naptitude install samba\n```\n```\ndpkg -s smbd\n```\n\n## Compartir una capeta\nCrear una carpeta\n```\nmkdir compartida\n```\nDarle permisos\n```\nchmod 777 -R compartida/\n```\nEditar el conf, agregar la carpeta compartida\n```\nvim /etc/samba/smb.conf\n```\n\nReisar bien el path\n```\n[comartida]\n\n   path = /compartida\n   browseable = yes\n   read only = yes\n   guest ok = no\n```\n\nAgregar determinados usuarios\n```\n[compartida]\n\t...\n\tvalid users = @marketing\n\tvalid list = @marketing\t\n```\n\nAgregar usuarios a samba\n```\nsmbpasswd -a pedro\n```\n\n### Importante\nreiniciar samba\n```\n/etc/init.d/smd restart\n```\n## Entrar desde el cliente\nIr al explorador de archivos\n```\n\\\\tuip\n```\n","lastmodified":"2022-06-29T20:47:29.114860503Z","tags":null},"/practicas/squid":{"title":"üí´ Squid","content":"\n## Prerequisitos\nTener aptitude\n```\napt-get install aptitude\n```\n\n## Instalar Squid\n```\naptitude install  squid\n```\n```\ndpkg -s squid\n```\n\nEditar el conf en la linea 1144\n```\nvim /etc/squid/squid.conf\n```\n\n### importante\nReiniciar squid\n```\n/etc/init.d/squid restart\n```","lastmodified":"2022-06-29T20:47:29.114860503Z","tags":null},"/practicas/ssh":{"title":"üç£ SSH","content":"\n## Prerequisitos\ninstalar vim\n```\napt-get install vim\n```\n\n## Cambiar puerto\nIr a:\n```\nvim /etc/ssh/sshd_config\n```\n\nse encontrara una linea asi:\n```\n#Port 22\n```\npara cambiar el puerto por el que se conectael ssh, por ejemplo a 234 se descomenta y se cambia el numero, por defecto es 22\n```\nPort 234\n```\n\n## Permitir determinados usuarios\nPermitir que solopuedan hacer loggin solo algunos usuarios, agregar al final del documento:\n```\nAllowUsers Joel\n```\nPermitir a usuarios de un determinado grupo\n```\nAllowGroups Marketing\n```\n\n## Permitir loggin como root\nBuscar la linea\n```\n#PermitRootLogin prohibit-password\n```\n\ny cambiarla a:\n```\nPermitRootLogin Yes\n```\n\n## Importante\nSiempre reiniciar el servicio para aplicar cambios\n```\n/etc/init.d/sshd restart\n```","lastmodified":"2022-06-29T20:47:29.114860503Z","tags":null},"/sistemas-distribuidos/Examen3/images/direct.jpg":{"title":"","content":"","lastmodified":"2022-06-29T20:47:29.182860997Z","tags":null}}